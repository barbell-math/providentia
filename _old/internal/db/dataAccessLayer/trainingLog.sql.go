// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trainingLog.sql

package dal

import (
	"context"

	"code.barbellmath.net/barbell-math/providentia/lib/types"
	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateTrainingLogsParams struct {
	ExerciseID       int32          `json:"exercise_id"`
	ClientID         int64          `json:"client_id"`
	PhysicsID        pgtype.Int8    `json:"physics_id"`
	DatePerformed    pgtype.Date    `json:"date_performed"`
	Weight           types.Kilogram `json:"weight"`
	Sets             float64        `json:"sets"`
	Reps             int32          `json:"reps"`
	Effort           types.RPE      `json:"effort"`
	InterSessionCntr int16          `json:"inter_session_cntr"`
	InterWorkoutCntr int16          `json:"inter_workout_cntr"`
}

const createPhysicsData = `-- name: CreatePhysicsData :one
INSERT INTO providentia.physics_data(
	path, bar_path_calc_id, bar_path_track_id,
	-- data
	time, position, velocity, acceleration, jerk,
	force, impulse, work, power,
	rep_splits,
	min_vel, max_vel,
	min_acc, max_acc,
	min_force, max_force,
	min_impulse, max_impulse,
	avg_work, min_work, max_work,
	avg_power, min_power, max_power
) VALUES (
	$1,
	(
		SELECT providentia.model.id FROM providentia.hyperparams
		JOIN providentia.model
			ON providentia.model.id = providentia.hyperparams.model_id
		WHERE providentia.model.name='BarPathCalc'
			AND providentia.hyperparams.version=$26
	),
	(
		SELECT providentia.model.id FROM providentia.hyperparams
		JOIN providentia.model
			ON providentia.model.id = providentia.hyperparams.model_id
		WHERE providentia.model.name='BarPathTracker'
			AND providentia.hyperparams.version=$27
	),
	$2,
	$3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
	$18, $19, $20, $21, $22, $23, $24, $25
) RETURNING id
`

type CreatePhysicsDataParams struct {
	Path                        []string                                                `json:"path"`
	Time                        [][]types.Second                                        `json:"time"`
	Position                    [][]types.Vec2[types.Meter, types.Meter]                `json:"position"`
	Velocity                    [][]types.Vec2[types.MeterPerSec, types.MeterPerSec]    `json:"velocity"`
	Acceleration                [][]types.Vec2[types.MeterPerSec2, types.MeterPerSec2]  `json:"acceleration"`
	Jerk                        [][]types.Vec2[types.MeterPerSec3, types.MeterPerSec3]  `json:"jerk"`
	Force                       [][]types.Vec2[types.Newton, types.Newton]              `json:"force"`
	Impulse                     [][]types.Vec2[types.NewtonSec, types.NewtonSec]        `json:"impulse"`
	Work                        [][]types.Joule                                         `json:"work"`
	Power                       [][]types.Watt                                          `json:"power"`
	RepSplits                   [][]types.Split                                         `json:"rep_splits"`
	MinVel                      [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"min_vel"`
	MaxVel                      [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"max_vel"`
	MinAcc                      [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"min_acc"`
	MaxAcc                      [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"max_acc"`
	MinForce                    [][]types.PointInTime[types.Second, types.Newton]       `json:"min_force"`
	MaxForce                    [][]types.PointInTime[types.Second, types.Newton]       `json:"max_force"`
	MinImpulse                  [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"min_impulse"`
	MaxImpulse                  [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"max_impulse"`
	AvgWork                     [][]types.Joule                                         `json:"avg_work"`
	MinWork                     [][]types.PointInTime[types.Second, types.Joule]        `json:"min_work"`
	MaxWork                     [][]types.PointInTime[types.Second, types.Joule]        `json:"max_work"`
	AvgPower                    [][]types.Watt                                          `json:"avg_power"`
	MinPower                    [][]types.PointInTime[types.Second, types.Watt]         `json:"min_power"`
	MaxPower                    [][]types.PointInTime[types.Second, types.Watt]         `json:"max_power"`
	BarPathCalcParamsVersion    int32                                                   `json:"bar_path_calc_params_version"`
	BarPathTrackerParamsVersion int32                                                   `json:"bar_path_tracker_params_version"`
}

func (q *Queries) CreatePhysicsData(ctx context.Context, arg CreatePhysicsDataParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPhysicsData,
		arg.Path,
		arg.Time,
		arg.Position,
		arg.Velocity,
		arg.Acceleration,
		arg.Jerk,
		arg.Force,
		arg.Impulse,
		arg.Work,
		arg.Power,
		arg.RepSplits,
		arg.MinVel,
		arg.MaxVel,
		arg.MinAcc,
		arg.MaxAcc,
		arg.MinForce,
		arg.MaxForce,
		arg.MinImpulse,
		arg.MaxImpulse,
		arg.AvgWork,
		arg.MinWork,
		arg.MaxWork,
		arg.AvgPower,
		arg.MinPower,
		arg.MaxPower,
		arg.BarPathCalcParamsVersion,
		arg.BarPathTrackerParamsVersion,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteWorkout = `-- name: DeleteWorkout :one
WITH deleted_exercises AS (
	DELETE FROM providentia.training_log
	USING providentia.client
	WHERE
		providentia.client.id = providentia.training_log.client_id AND
		providentia.client.email = $1 AND
		providentia.training_log.inter_session_cntr = $2 AND
		providentia.training_log.date_performed = $3
	RETURNING providentia.training_log.id
) SELECT COUNT(*) FROM deleted_exercises
`

type DeleteWorkoutParams struct {
	Email            string      `json:"email"`
	InterSessionCntr int16       `json:"inter_session_cntr"`
	DatePerformed    pgtype.Date `json:"date_performed"`
}

func (q *Queries) DeleteWorkout(ctx context.Context, arg DeleteWorkoutParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteWorkout, arg.Email, arg.InterSessionCntr, arg.DatePerformed)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteWorkoutsBetweenDates = `-- name: DeleteWorkoutsBetweenDates :one
WITH deleted_exercises AS (
	DELETE FROM providentia.training_log
	USING providentia.client
	WHERE
		providentia.client.id = providentia.training_log.client_id AND
		providentia.client.email = $1 AND
		providentia.training_log.date_performed BETWEEN $2::DATE AND $3::DATE
	RETURNING providentia.training_log.id
) SELECT COUNT(*) FROM deleted_exercises
`

type DeleteWorkoutsBetweenDatesParams struct {
	Email  string      `json:"email"`
	Start  pgtype.Date `json:"start"`
	Ending pgtype.Date `json:"ending"`
}

func (q *Queries) DeleteWorkoutsBetweenDates(ctx context.Context, arg DeleteWorkoutsBetweenDatesParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteWorkoutsBetweenDates, arg.Email, arg.Start, arg.Ending)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllWorkoutData = `-- name: GetAllWorkoutData :many
SELECT
	providentia.exercise.name,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.volume,
	providentia.training_log.exertion,
	providentia.training_log.total_reps,
	providentia.physics_data.time,
	providentia.physics_data.position,
	providentia.physics_data.velocity,
	providentia.physics_data.acceleration,
	providentia.physics_data.jerk,
	providentia.physics_data.force,
	providentia.physics_data.impulse,
	providentia.physics_data.work,
	providentia.physics_data.power,
	providentia.physics_data.rep_splits,
	providentia.physics_data.min_vel,
	providentia.physics_data.max_vel,
	providentia.physics_data.min_acc,
	providentia.physics_data.max_acc,
	providentia.physics_data.min_force,
	providentia.physics_data.max_force,
	providentia.physics_data.min_impulse,
	providentia.physics_data.max_impulse,
	providentia.physics_data.avg_work,
	providentia.physics_data.min_work,
	providentia.physics_data.max_work,
	providentia.physics_data.avg_power,
	providentia.physics_data.min_power,
	providentia.physics_data.max_power
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
LEFT JOIN providentia.physics_data
	ON providentia.training_log.physics_id=providentia.physics_data.id
WHERE
	providentia.client.email = $1 AND
	providentia.training_log.inter_session_cntr = $2 AND
	providentia.training_log.date_performed = $3
ORDER BY training_log.inter_workout_cntr ASC
`

type GetAllWorkoutDataParams struct {
	Email            string      `json:"email"`
	InterSessionCntr int16       `json:"inter_session_cntr"`
	DatePerformed    pgtype.Date `json:"date_performed"`
}

type GetAllWorkoutDataRow struct {
	Name         string                                                  `json:"name"`
	Weight       types.Kilogram                                          `json:"weight"`
	Sets         float64                                                 `json:"sets"`
	Reps         int32                                                   `json:"reps"`
	Effort       types.RPE                                               `json:"effort"`
	Volume       types.Kilogram                                          `json:"volume"`
	Exertion     types.RPE                                               `json:"exertion"`
	TotalReps    float64                                                 `json:"total_reps"`
	Time         [][]types.Second                                        `json:"time"`
	Position     [][]types.Vec2[types.Meter, types.Meter]                `json:"position"`
	Velocity     [][]types.Vec2[types.MeterPerSec, types.MeterPerSec]    `json:"velocity"`
	Acceleration [][]types.Vec2[types.MeterPerSec2, types.MeterPerSec2]  `json:"acceleration"`
	Jerk         [][]types.Vec2[types.MeterPerSec3, types.MeterPerSec3]  `json:"jerk"`
	Force        [][]types.Vec2[types.Newton, types.Newton]              `json:"force"`
	Impulse      [][]types.Vec2[types.NewtonSec, types.NewtonSec]        `json:"impulse"`
	Work         [][]types.Joule                                         `json:"work"`
	Power        [][]types.Watt                                          `json:"power"`
	RepSplits    [][]types.Split                                         `json:"rep_splits"`
	MinVel       [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"min_vel"`
	MaxVel       [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"max_vel"`
	MinAcc       [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"min_acc"`
	MaxAcc       [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"max_acc"`
	MinForce     [][]types.PointInTime[types.Second, types.Newton]       `json:"min_force"`
	MaxForce     [][]types.PointInTime[types.Second, types.Newton]       `json:"max_force"`
	MinImpulse   [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"min_impulse"`
	MaxImpulse   [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"max_impulse"`
	AvgWork      [][]types.Joule                                         `json:"avg_work"`
	MinWork      [][]types.PointInTime[types.Second, types.Joule]        `json:"min_work"`
	MaxWork      [][]types.PointInTime[types.Second, types.Joule]        `json:"max_work"`
	AvgPower     [][]types.Watt                                          `json:"avg_power"`
	MinPower     [][]types.PointInTime[types.Second, types.Watt]         `json:"min_power"`
	MaxPower     [][]types.PointInTime[types.Second, types.Watt]         `json:"max_power"`
}

// TODO - figure out if ordinality trick can be used here - is there a way to
// make the join on multiple columns?
func (q *Queries) GetAllWorkoutData(ctx context.Context, arg GetAllWorkoutDataParams) ([]GetAllWorkoutDataRow, error) {
	rows, err := q.db.Query(ctx, getAllWorkoutData, arg.Email, arg.InterSessionCntr, arg.DatePerformed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllWorkoutDataRow
	for rows.Next() {
		var i GetAllWorkoutDataRow
		if err := rows.Scan(
			&i.Name,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Volume,
			&i.Exertion,
			&i.TotalReps,
			&i.Time,
			&i.Position,
			&i.Velocity,
			&i.Acceleration,
			&i.Jerk,
			&i.Force,
			&i.Impulse,
			&i.Work,
			&i.Power,
			&i.RepSplits,
			&i.MinVel,
			&i.MaxVel,
			&i.MinAcc,
			&i.MaxAcc,
			&i.MinForce,
			&i.MaxForce,
			&i.MinImpulse,
			&i.MaxImpulse,
			&i.AvgWork,
			&i.MinWork,
			&i.MaxWork,
			&i.AvgPower,
			&i.MinPower,
			&i.MaxPower,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWorkoutDataBetweenDates = `-- name: GetAllWorkoutDataBetweenDates :many
SELECT
	providentia.exercise.name,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.volume,
	providentia.training_log.exertion,
	providentia.training_log.total_reps,
	providentia.training_log.date_performed,
	providentia.training_log.inter_session_cntr,
	providentia.physics_data.time,
	providentia.physics_data.position,
	providentia.physics_data.velocity,
	providentia.physics_data.acceleration,
	providentia.physics_data.jerk,
	providentia.physics_data.force,
	providentia.physics_data.impulse,
	providentia.physics_data.work,
	providentia.physics_data.power,
	providentia.physics_data.rep_splits,
	providentia.physics_data.min_vel,
	providentia.physics_data.max_vel,
	providentia.physics_data.min_acc,
	providentia.physics_data.max_acc,
	providentia.physics_data.min_force,
	providentia.physics_data.max_force,
	providentia.physics_data.min_impulse,
	providentia.physics_data.max_impulse,
	providentia.physics_data.avg_work,
	providentia.physics_data.min_work,
	providentia.physics_data.max_work,
	providentia.physics_data.avg_power,
	providentia.physics_data.min_power,
	providentia.physics_data.max_power
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
LEFT JOIN providentia.physics_data
	ON providentia.training_log.physics_id=providentia.physics_data.id
WHERE
	providentia.client.email = $1 AND
	providentia.training_log.date_performed BETWEEN $2::DATE AND $3::DATE
ORDER BY 
	training_log.date_performed ASC,
	training_log.inter_session_cntr ASC,
	training_log.inter_workout_cntr ASC
`

type GetAllWorkoutDataBetweenDatesParams struct {
	Email  string      `json:"email"`
	Start  pgtype.Date `json:"start"`
	Ending pgtype.Date `json:"ending"`
}

type GetAllWorkoutDataBetweenDatesRow struct {
	Name             string                                                  `json:"name"`
	Weight           types.Kilogram                                          `json:"weight"`
	Sets             float64                                                 `json:"sets"`
	Reps             int32                                                   `json:"reps"`
	Effort           types.RPE                                               `json:"effort"`
	Volume           types.Kilogram                                          `json:"volume"`
	Exertion         types.RPE                                               `json:"exertion"`
	TotalReps        float64                                                 `json:"total_reps"`
	DatePerformed    pgtype.Date                                             `json:"date_performed"`
	InterSessionCntr int16                                                   `json:"inter_session_cntr"`
	Time             [][]types.Second                                        `json:"time"`
	Position         [][]types.Vec2[types.Meter, types.Meter]                `json:"position"`
	Velocity         [][]types.Vec2[types.MeterPerSec, types.MeterPerSec]    `json:"velocity"`
	Acceleration     [][]types.Vec2[types.MeterPerSec2, types.MeterPerSec2]  `json:"acceleration"`
	Jerk             [][]types.Vec2[types.MeterPerSec3, types.MeterPerSec3]  `json:"jerk"`
	Force            [][]types.Vec2[types.Newton, types.Newton]              `json:"force"`
	Impulse          [][]types.Vec2[types.NewtonSec, types.NewtonSec]        `json:"impulse"`
	Work             [][]types.Joule                                         `json:"work"`
	Power            [][]types.Watt                                          `json:"power"`
	RepSplits        [][]types.Split                                         `json:"rep_splits"`
	MinVel           [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"min_vel"`
	MaxVel           [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"max_vel"`
	MinAcc           [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"min_acc"`
	MaxAcc           [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"max_acc"`
	MinForce         [][]types.PointInTime[types.Second, types.Newton]       `json:"min_force"`
	MaxForce         [][]types.PointInTime[types.Second, types.Newton]       `json:"max_force"`
	MinImpulse       [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"min_impulse"`
	MaxImpulse       [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"max_impulse"`
	AvgWork          [][]types.Joule                                         `json:"avg_work"`
	MinWork          [][]types.PointInTime[types.Second, types.Joule]        `json:"min_work"`
	MaxWork          [][]types.PointInTime[types.Second, types.Joule]        `json:"max_work"`
	AvgPower         [][]types.Watt                                          `json:"avg_power"`
	MinPower         [][]types.PointInTime[types.Second, types.Watt]         `json:"min_power"`
	MaxPower         [][]types.PointInTime[types.Second, types.Watt]         `json:"max_power"`
}

func (q *Queries) GetAllWorkoutDataBetweenDates(ctx context.Context, arg GetAllWorkoutDataBetweenDatesParams) ([]GetAllWorkoutDataBetweenDatesRow, error) {
	rows, err := q.db.Query(ctx, getAllWorkoutDataBetweenDates, arg.Email, arg.Start, arg.Ending)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllWorkoutDataBetweenDatesRow
	for rows.Next() {
		var i GetAllWorkoutDataBetweenDatesRow
		if err := rows.Scan(
			&i.Name,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Volume,
			&i.Exertion,
			&i.TotalReps,
			&i.DatePerformed,
			&i.InterSessionCntr,
			&i.Time,
			&i.Position,
			&i.Velocity,
			&i.Acceleration,
			&i.Jerk,
			&i.Force,
			&i.Impulse,
			&i.Work,
			&i.Power,
			&i.RepSplits,
			&i.MinVel,
			&i.MaxVel,
			&i.MinAcc,
			&i.MaxAcc,
			&i.MinForce,
			&i.MaxForce,
			&i.MinImpulse,
			&i.MaxImpulse,
			&i.AvgWork,
			&i.MinWork,
			&i.MaxWork,
			&i.AvgPower,
			&i.MinPower,
			&i.MaxPower,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumWorkoutsForClient = `-- name: GetNumWorkoutsForClient :one
SELECT COUNT(*) FROM (
	SELECT date_performed, inter_session_cntr
	FROM providentia.training_log
	JOIN providentia.client
		ON providentia.training_log.client_id = providentia.client.id
	WHERE providentia.client.email = $1
	GROUP BY date_performed, inter_session_cntr
) AS result
`

func (q *Queries) GetNumWorkoutsForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getNumWorkoutsForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRawWorkoutData = `-- name: GetRawWorkoutData :many
SELECT
	providentia.exercise.name,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.physics_data.path,
	providentia.physics_data.time,
	providentia.physics_data.position
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
LEFT JOIN providentia.physics_data
	ON providentia.training_log.physics_id=providentia.physics_data.id
WHERE
	providentia.client.email = $1 AND
	providentia.training_log.inter_session_cntr = $2 AND
	providentia.training_log.date_performed = $3
ORDER BY training_log.inter_workout_cntr ASC
`

type GetRawWorkoutDataParams struct {
	Email            string      `json:"email"`
	InterSessionCntr int16       `json:"inter_session_cntr"`
	DatePerformed    pgtype.Date `json:"date_performed"`
}

type GetRawWorkoutDataRow struct {
	Name     string                                   `json:"name"`
	Weight   types.Kilogram                           `json:"weight"`
	Sets     float64                                  `json:"sets"`
	Reps     int32                                    `json:"reps"`
	Effort   types.RPE                                `json:"effort"`
	Path     []string                                 `json:"path"`
	Time     [][]types.Second                         `json:"time"`
	Position [][]types.Vec2[types.Meter, types.Meter] `json:"position"`
}

func (q *Queries) GetRawWorkoutData(ctx context.Context, arg GetRawWorkoutDataParams) ([]GetRawWorkoutDataRow, error) {
	rows, err := q.db.Query(ctx, getRawWorkoutData, arg.Email, arg.InterSessionCntr, arg.DatePerformed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRawWorkoutDataRow
	for rows.Next() {
		var i GetRawWorkoutDataRow
		if err := rows.Scan(
			&i.Name,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Path,
			&i.Time,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalNumPhysicsEntriesForClient = `-- name: GetTotalNumPhysicsEntriesForClient :one
SELECT COUNT(*) FROM providentia.physics_data
JOIN providentia.training_log
	ON providentia.physics_data.id = providentia.training_log.physics_id
JOIN providentia.client
	ON providentia.training_log.client_id = providentia.client.id
WHERE
	providentia.client.email = $1
`

func (q *Queries) GetTotalNumPhysicsEntriesForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNumPhysicsEntriesForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalNumTrainingLogEntriesForClient = `-- name: GetTotalNumTrainingLogEntriesForClient :one
SELECT COUNT(*) FROM providentia.training_log
JOIN providentia.client
	ON providentia.training_log.client_id = providentia.client.id
WHERE providentia.client.email = $1
`

func (q *Queries) GetTotalNumTrainingLogEntriesForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNumTrainingLogEntriesForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}
