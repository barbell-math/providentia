// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exercise.sql

package dal

import (
	"context"

	"code.barbellmath.net/barbell-math/providentia/lib/types"
)

type BulkCreateExerciseWithIDParams struct {
	ID      int32               `json:"id"`
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

type BulkCreateExercisesParams struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

const deleteExercisesByName = `-- name: DeleteExercisesByName :one
WITH deleted_exercises AS (
	DELETE FROM providentia.exercise
	WHERE name = ANY($1::TEXT[])
	RETURNING id
) SELECT COUNT(*) FROM deleted_exercises
`

func (q *Queries) DeleteExercisesByName(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, deleteExercisesByName, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const ensureExercisesExist = `-- name: EnsureExercisesExist :exec
INSERT INTO providentia.exercise (name, kind_id, focus_id)
SELECT
	UNNEST($1::TEXT[]),
	UNNEST($2::INT4[]),
	UNNEST($3::INT4[])
ON CONFLICT (name, kind_id, focus_id) DO NOTHING
`

type EnsureExercisesExistParams struct {
	Names   []string `json:"names"`
	Kinds   []int32  `json:"kinds"`
	Focuses []int32  `json:"focuses"`
}

func (q *Queries) EnsureExercisesExist(ctx context.Context, arg EnsureExercisesExistParams) error {
	_, err := q.db.Exec(ctx, ensureExercisesExist, arg.Names, arg.Kinds, arg.Focuses)
	return err
}

const findExercisesByName = `-- name: FindExercisesByName :many
SELECT
	providentia.exercise.name,
	providentia.exercise.kind_id,
	providentia.exercise.focus_id,
	ord::INT8
FROM providentia.exercise 
JOIN UNNEST($1::TEXT[])
WITH ORDINALITY t(name, ord)
USING (name) 
ORDER BY ord
`

type FindExercisesByNameRow struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
	Ord     int64               `json:"ord"`
}

// Note: this is different from GetExercisesByName because it returns a ordinal
// value. The ordinal value allows for checking that the requested exercises
// existed in the database.
func (q *Queries) FindExercisesByName(ctx context.Context, dollar_1 []string) ([]FindExercisesByNameRow, error) {
	rows, err := q.db.Query(ctx, findExercisesByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindExercisesByNameRow
	for rows.Next() {
		var i FindExercisesByNameRow
		if err := rows.Scan(
			&i.Name,
			&i.KindID,
			&i.FocusID,
			&i.Ord,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseIdByName = `-- name: GetExerciseIdByName :one
SELECT id FROM providentia.exercise WHERE name = $1
`

func (q *Queries) GetExerciseIdByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getExerciseIdByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getExercisesByName = `-- name: GetExercisesByName :many
SELECT
	providentia.exercise.name,
	providentia.exercise.kind_id,
	providentia.exercise.focus_id
FROM providentia.exercise 
JOIN UNNEST($1::TEXT[])
WITH ORDINALITY t(name, ord)
USING (name)
ORDER BY ord
`

type GetExercisesByNameRow struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

func (q *Queries) GetExercisesByName(ctx context.Context, dollar_1 []string) ([]GetExercisesByNameRow, error) {
	rows, err := q.db.Query(ctx, getExercisesByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExercisesByNameRow
	for rows.Next() {
		var i GetExercisesByNameRow
		if err := rows.Scan(&i.Name, &i.KindID, &i.FocusID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumExercises = `-- name: GetNumExercises :one
SELECT COUNT(*) FROM providentia.exercise
`

func (q *Queries) GetNumExercises(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumExercises)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateExerciseByName = `-- name: UpdateExerciseByName :exec
UPDATE providentia.exercise SET kind_id=$2, focus_id=$3
WHERE providentia.exercise.name=$1
`

type UpdateExerciseByNameParams struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

func (q *Queries) UpdateExerciseByName(ctx context.Context, arg UpdateExerciseByNameParams) error {
	_, err := q.db.Exec(ctx, updateExerciseByName, arg.Name, arg.KindID, arg.FocusID)
	return err
}

const updateExerciseSerialCount = `-- name: UpdateExerciseSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise', 'id'),
	(SELECT MAX(id) FROM providentia.exercise) + 1
)
`

func (q *Queries) UpdateExerciseSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseSerialCount)
	return err
}
