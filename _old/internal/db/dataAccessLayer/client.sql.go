// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: client.sql

package dal

import (
	"context"
)

type BulkCreateClientsParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

const clientExists = `-- name: ClientExists :one
SELECT EXISTS(SELECT 1 FROM providentia.client WHERE email = $1)
`

func (q *Queries) ClientExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, clientExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteClientsByEmail = `-- name: DeleteClientsByEmail :one
WITH deleted_clients AS (
    DELETE FROM providentia.client
    WHERE email = ANY($1::TEXT[])
    RETURNING id
) SELECT COUNT(*) FROM deleted_clients
`

func (q *Queries) DeleteClientsByEmail(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, deleteClientsByEmail, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const ensureClientsExist = `-- name: EnsureClientsExist :exec
INSERT INTO providentia.client (first_name, last_name, email)
SELECT
	UNNEST($1::TEXT[]),
	UNNEST($2::TEXT[]),
	UNNEST($3::TEXT[])
ON CONFLICT (first_name, last_name, email) DO NOTHING
`

type EnsureClientsExistParams struct {
	FirstNames []string `json:"first_names"`
	LastNames  []string `json:"last_names"`
	Emails     []string `json:"emails"`
}

func (q *Queries) EnsureClientsExist(ctx context.Context, arg EnsureClientsExistParams) error {
	_, err := q.db.Exec(ctx, ensureClientsExist, arg.FirstNames, arg.LastNames, arg.Emails)
	return err
}

const findClientsByEmail = `-- name: FindClientsByEmail :many
SELECT
	providentia.client.first_name,
	providentia.client.last_name,
	providentia.client.email,
	ord::INT8
FROM providentia.client 
JOIN UNNEST($1::TEXT[])
WITH ORDINALITY t(email, ord)
USING (email) 
ORDER BY ord
`

type FindClientsByEmailRow struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
	Ord       int64  `json:"ord"`
}

// Note: this is different from GetClientsByEmail because it returns a ordinal
// value. The ordinal value allows for checking that the requested clients
// existed in the database.
func (q *Queries) FindClientsByEmail(ctx context.Context, dollar_1 []string) ([]FindClientsByEmailRow, error) {
	rows, err := q.db.Query(ctx, findClientsByEmail, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindClientsByEmailRow
	for rows.Next() {
		var i FindClientsByEmailRow
		if err := rows.Scan(
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Ord,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientIdByEmail = `-- name: GetClientIdByEmail :one
SELECT id FROM providentia.client WHERE email = $1
`

func (q *Queries) GetClientIdByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getClientIdByEmail, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getClientsByEmail = `-- name: GetClientsByEmail :many
SELECT
	providentia.client.first_name,
	providentia.client.last_name,
	providentia.client.email
FROM providentia.client 
JOIN UNNEST($1::TEXT[])
WITH ORDINALITY t(email, ord)
USING (email) 
ORDER BY ord
`

type GetClientsByEmailRow struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) GetClientsByEmail(ctx context.Context, dollar_1 []string) ([]GetClientsByEmailRow, error) {
	rows, err := q.db.Query(ctx, getClientsByEmail, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientsByEmailRow
	for rows.Next() {
		var i GetClientsByEmailRow
		if err := rows.Scan(&i.FirstName, &i.LastName, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumClients = `-- name: GetNumClients :one
SELECT COUNT(*) FROM providentia.client
`

func (q *Queries) GetNumClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumClients)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateClientByEmail = `-- name: UpdateClientByEmail :exec
UPDATE providentia.client SET first_name=$1, last_name=$2
WHERE providentia.client.email=$3
`

type UpdateClientByEmailParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) UpdateClientByEmail(ctx context.Context, arg UpdateClientByEmailParams) error {
	_, err := q.db.Exec(ctx, updateClientByEmail, arg.FirstName, arg.LastName, arg.Email)
	return err
}
