// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package types

import (
	"fmt"
	"strings"
)

const (
	// SecondOrder is a ApproximationError of type SecondOrder.
	SecondOrder ApproximationError = iota + 2
	// FourthOrder is a ApproximationError of type FourthOrder.
	FourthOrder ApproximationError = iota + 3
)

var ErrInvalidApproximationError = fmt.Errorf("not a valid ApproximationError, try [%s]", strings.Join(_ApproximationErrorNames, ", "))

const _ApproximationErrorName = "SecondOrderFourthOrder"

var _ApproximationErrorNames = []string{
	_ApproximationErrorName[0:11],
	_ApproximationErrorName[11:22],
}

// ApproximationErrorNames returns a list of possible string values of ApproximationError.
func ApproximationErrorNames() []string {
	tmp := make([]string, len(_ApproximationErrorNames))
	copy(tmp, _ApproximationErrorNames)
	return tmp
}

// ApproximationErrorValues returns a list of the values for ApproximationError
func ApproximationErrorValues() []ApproximationError {
	return []ApproximationError{
		SecondOrder,
		FourthOrder,
	}
}

var _ApproximationErrorMap = map[ApproximationError]string{
	SecondOrder: _ApproximationErrorName[0:11],
	FourthOrder: _ApproximationErrorName[11:22],
}

// String implements the Stringer interface.
func (x ApproximationError) String() string {
	if str, ok := _ApproximationErrorMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ApproximationError(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ApproximationError) IsValid() bool {
	_, ok := _ApproximationErrorMap[x]
	return ok
}

var _ApproximationErrorValue = map[string]ApproximationError{
	_ApproximationErrorName[0:11]:                   SecondOrder,
	strings.ToLower(_ApproximationErrorName[0:11]):  SecondOrder,
	_ApproximationErrorName[11:22]:                  FourthOrder,
	strings.ToLower(_ApproximationErrorName[11:22]): FourthOrder,
}

// ParseApproximationError attempts to convert a string to a ApproximationError.
func ParseApproximationError(name string) (ApproximationError, error) {
	if x, ok := _ApproximationErrorValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ApproximationErrorValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ApproximationError(0), fmt.Errorf("%s is %w", name, ErrInvalidApproximationError)
}

// MarshalText implements the text marshaller method.
func (x ApproximationError) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ApproximationError) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseApproximationError(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ApproximationError) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// NoBarPathData is a BarPathFlag of type NoBarPathData.
	NoBarPathData BarPathFlag = iota
	// VideoBarPathData is a BarPathFlag of type VideoBarPathData.
	VideoBarPathData
	// TimeSeriesBarPathData is a BarPathFlag of type TimeSeriesBarPathData.
	TimeSeriesBarPathData
)

var ErrInvalidBarPathFlag = fmt.Errorf("not a valid BarPathFlag, try [%s]", strings.Join(_BarPathFlagNames, ", "))

const _BarPathFlagName = "NoBarPathDataVideoBarPathDataTimeSeriesBarPathData"

var _BarPathFlagNames = []string{
	_BarPathFlagName[0:13],
	_BarPathFlagName[13:29],
	_BarPathFlagName[29:50],
}

// BarPathFlagNames returns a list of possible string values of BarPathFlag.
func BarPathFlagNames() []string {
	tmp := make([]string, len(_BarPathFlagNames))
	copy(tmp, _BarPathFlagNames)
	return tmp
}

// BarPathFlagValues returns a list of the values for BarPathFlag
func BarPathFlagValues() []BarPathFlag {
	return []BarPathFlag{
		NoBarPathData,
		VideoBarPathData,
		TimeSeriesBarPathData,
	}
}

var _BarPathFlagMap = map[BarPathFlag]string{
	NoBarPathData:         _BarPathFlagName[0:13],
	VideoBarPathData:      _BarPathFlagName[13:29],
	TimeSeriesBarPathData: _BarPathFlagName[29:50],
}

// String implements the Stringer interface.
func (x BarPathFlag) String() string {
	if str, ok := _BarPathFlagMap[x]; ok {
		return str
	}
	return fmt.Sprintf("BarPathFlag(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BarPathFlag) IsValid() bool {
	_, ok := _BarPathFlagMap[x]
	return ok
}

var _BarPathFlagValue = map[string]BarPathFlag{
	_BarPathFlagName[0:13]:                   NoBarPathData,
	strings.ToLower(_BarPathFlagName[0:13]):  NoBarPathData,
	_BarPathFlagName[13:29]:                  VideoBarPathData,
	strings.ToLower(_BarPathFlagName[13:29]): VideoBarPathData,
	_BarPathFlagName[29:50]:                  TimeSeriesBarPathData,
	strings.ToLower(_BarPathFlagName[29:50]): TimeSeriesBarPathData,
}

// ParseBarPathFlag attempts to convert a string to a BarPathFlag.
func ParseBarPathFlag(name string) (BarPathFlag, error) {
	if x, ok := _BarPathFlagValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _BarPathFlagValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return BarPathFlag(0), fmt.Errorf("%s is %w", name, ErrInvalidBarPathFlag)
}

// MarshalText implements the text marshaller method.
func (x BarPathFlag) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BarPathFlag) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseBarPathFlag(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *BarPathFlag) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// Create is a CreateFuncType of type Create.
	Create CreateFuncType = iota
	// EnsureExists is a CreateFuncType of type EnsureExists.
	EnsureExists
)

var ErrInvalidCreateFuncType = fmt.Errorf("not a valid CreateFuncType, try [%s]", strings.Join(_CreateFuncTypeNames, ", "))

const _CreateFuncTypeName = "CreateEnsureExists"

var _CreateFuncTypeNames = []string{
	_CreateFuncTypeName[0:6],
	_CreateFuncTypeName[6:18],
}

// CreateFuncTypeNames returns a list of possible string values of CreateFuncType.
func CreateFuncTypeNames() []string {
	tmp := make([]string, len(_CreateFuncTypeNames))
	copy(tmp, _CreateFuncTypeNames)
	return tmp
}

// CreateFuncTypeValues returns a list of the values for CreateFuncType
func CreateFuncTypeValues() []CreateFuncType {
	return []CreateFuncType{
		Create,
		EnsureExists,
	}
}

var _CreateFuncTypeMap = map[CreateFuncType]string{
	Create:       _CreateFuncTypeName[0:6],
	EnsureExists: _CreateFuncTypeName[6:18],
}

// String implements the Stringer interface.
func (x CreateFuncType) String() string {
	if str, ok := _CreateFuncTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CreateFuncType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CreateFuncType) IsValid() bool {
	_, ok := _CreateFuncTypeMap[x]
	return ok
}

var _CreateFuncTypeValue = map[string]CreateFuncType{
	_CreateFuncTypeName[0:6]:                   Create,
	strings.ToLower(_CreateFuncTypeName[0:6]):  Create,
	_CreateFuncTypeName[6:18]:                  EnsureExists,
	strings.ToLower(_CreateFuncTypeName[6:18]): EnsureExists,
}

// ParseCreateFuncType attempts to convert a string to a CreateFuncType.
func ParseCreateFuncType(name string) (CreateFuncType, error) {
	if x, ok := _CreateFuncTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _CreateFuncTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return CreateFuncType(0), fmt.Errorf("%s is %w", name, ErrInvalidCreateFuncType)
}

// MarshalText implements the text marshaller method.
func (x CreateFuncType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *CreateFuncType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCreateFuncType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *CreateFuncType) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// UnknownExerciseFocus is a ExerciseFocus of type UnknownExerciseFocus.
	UnknownExerciseFocus ExerciseFocus = iota
	// Squat is a ExerciseFocus of type Squat.
	Squat
	// Bench is a ExerciseFocus of type Bench.
	Bench
	// Deadlift is a ExerciseFocus of type Deadlift.
	Deadlift
)

var ErrInvalidExerciseFocus = fmt.Errorf("not a valid ExerciseFocus, try [%s]", strings.Join(_ExerciseFocusNames, ", "))

const _ExerciseFocusName = "UnknownExerciseFocusSquatBenchDeadlift"

var _ExerciseFocusNames = []string{
	_ExerciseFocusName[0:20],
	_ExerciseFocusName[20:25],
	_ExerciseFocusName[25:30],
	_ExerciseFocusName[30:38],
}

// ExerciseFocusNames returns a list of possible string values of ExerciseFocus.
func ExerciseFocusNames() []string {
	tmp := make([]string, len(_ExerciseFocusNames))
	copy(tmp, _ExerciseFocusNames)
	return tmp
}

// ExerciseFocusValues returns a list of the values for ExerciseFocus
func ExerciseFocusValues() []ExerciseFocus {
	return []ExerciseFocus{
		UnknownExerciseFocus,
		Squat,
		Bench,
		Deadlift,
	}
}

var _ExerciseFocusMap = map[ExerciseFocus]string{
	UnknownExerciseFocus: _ExerciseFocusName[0:20],
	Squat:                _ExerciseFocusName[20:25],
	Bench:                _ExerciseFocusName[25:30],
	Deadlift:             _ExerciseFocusName[30:38],
}

// String implements the Stringer interface.
func (x ExerciseFocus) String() string {
	if str, ok := _ExerciseFocusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExerciseFocus(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExerciseFocus) IsValid() bool {
	_, ok := _ExerciseFocusMap[x]
	return ok
}

var _ExerciseFocusValue = map[string]ExerciseFocus{
	_ExerciseFocusName[0:20]:                   UnknownExerciseFocus,
	strings.ToLower(_ExerciseFocusName[0:20]):  UnknownExerciseFocus,
	_ExerciseFocusName[20:25]:                  Squat,
	strings.ToLower(_ExerciseFocusName[20:25]): Squat,
	_ExerciseFocusName[25:30]:                  Bench,
	strings.ToLower(_ExerciseFocusName[25:30]): Bench,
	_ExerciseFocusName[30:38]:                  Deadlift,
	strings.ToLower(_ExerciseFocusName[30:38]): Deadlift,
}

// ParseExerciseFocus attempts to convert a string to a ExerciseFocus.
func ParseExerciseFocus(name string) (ExerciseFocus, error) {
	if x, ok := _ExerciseFocusValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ExerciseFocusValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ExerciseFocus(0), fmt.Errorf("%s is %w", name, ErrInvalidExerciseFocus)
}

// MarshalText implements the text marshaller method.
func (x ExerciseFocus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ExerciseFocus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseExerciseFocus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ExerciseFocus) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// MainCompound is a ExerciseKind of type MainCompound.
	MainCompound ExerciseKind = iota + 1
	// MainCompoundAccessory is a ExerciseKind of type MainCompoundAccessory.
	MainCompoundAccessory
	// CompoundAccessory is a ExerciseKind of type CompoundAccessory.
	CompoundAccessory
	// Accessory is a ExerciseKind of type Accessory.
	Accessory
)

var ErrInvalidExerciseKind = fmt.Errorf("not a valid ExerciseKind, try [%s]", strings.Join(_ExerciseKindNames, ", "))

const _ExerciseKindName = "MainCompoundMainCompoundAccessoryCompoundAccessoryAccessory"

var _ExerciseKindNames = []string{
	_ExerciseKindName[0:12],
	_ExerciseKindName[12:33],
	_ExerciseKindName[33:50],
	_ExerciseKindName[50:59],
}

// ExerciseKindNames returns a list of possible string values of ExerciseKind.
func ExerciseKindNames() []string {
	tmp := make([]string, len(_ExerciseKindNames))
	copy(tmp, _ExerciseKindNames)
	return tmp
}

// ExerciseKindValues returns a list of the values for ExerciseKind
func ExerciseKindValues() []ExerciseKind {
	return []ExerciseKind{
		MainCompound,
		MainCompoundAccessory,
		CompoundAccessory,
		Accessory,
	}
}

var _ExerciseKindMap = map[ExerciseKind]string{
	MainCompound:          _ExerciseKindName[0:12],
	MainCompoundAccessory: _ExerciseKindName[12:33],
	CompoundAccessory:     _ExerciseKindName[33:50],
	Accessory:             _ExerciseKindName[50:59],
}

// String implements the Stringer interface.
func (x ExerciseKind) String() string {
	if str, ok := _ExerciseKindMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExerciseKind(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExerciseKind) IsValid() bool {
	_, ok := _ExerciseKindMap[x]
	return ok
}

var _ExerciseKindValue = map[string]ExerciseKind{
	_ExerciseKindName[0:12]:                   MainCompound,
	strings.ToLower(_ExerciseKindName[0:12]):  MainCompound,
	_ExerciseKindName[12:33]:                  MainCompoundAccessory,
	strings.ToLower(_ExerciseKindName[12:33]): MainCompoundAccessory,
	_ExerciseKindName[33:50]:                  CompoundAccessory,
	strings.ToLower(_ExerciseKindName[33:50]): CompoundAccessory,
	_ExerciseKindName[50:59]:                  Accessory,
	strings.ToLower(_ExerciseKindName[50:59]): Accessory,
}

// ParseExerciseKind attempts to convert a string to a ExerciseKind.
func ParseExerciseKind(name string) (ExerciseKind, error) {
	if x, ok := _ExerciseKindValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ExerciseKindValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ExerciseKind(0), fmt.Errorf("%s is %w", name, ErrInvalidExerciseKind)
}

// MarshalText implements the text marshaller method.
func (x ExerciseKind) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ExerciseKind) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseExerciseKind(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ExerciseKind) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// UnknownModel is a ModelID of type UnknownModel.
	UnknownModel ModelID = iota
	// BarPathTracker is a ModelID of type BarPathTracker.
	BarPathTracker
	// BarPathCalc is a ModelID of type BarPathCalc.
	BarPathCalc
)

var ErrInvalidModelID = fmt.Errorf("not a valid ModelID, try [%s]", strings.Join(_ModelIDNames, ", "))

const _ModelIDName = "UnknownModelBarPathTrackerBarPathCalc"

var _ModelIDNames = []string{
	_ModelIDName[0:12],
	_ModelIDName[12:26],
	_ModelIDName[26:37],
}

// ModelIDNames returns a list of possible string values of ModelID.
func ModelIDNames() []string {
	tmp := make([]string, len(_ModelIDNames))
	copy(tmp, _ModelIDNames)
	return tmp
}

// ModelIDValues returns a list of the values for ModelID
func ModelIDValues() []ModelID {
	return []ModelID{
		UnknownModel,
		BarPathTracker,
		BarPathCalc,
	}
}

var _ModelIDMap = map[ModelID]string{
	UnknownModel:   _ModelIDName[0:12],
	BarPathTracker: _ModelIDName[12:26],
	BarPathCalc:    _ModelIDName[26:37],
}

// String implements the Stringer interface.
func (x ModelID) String() string {
	if str, ok := _ModelIDMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ModelID(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ModelID) IsValid() bool {
	_, ok := _ModelIDMap[x]
	return ok
}

var _ModelIDValue = map[string]ModelID{
	_ModelIDName[0:12]:                   UnknownModel,
	strings.ToLower(_ModelIDName[0:12]):  UnknownModel,
	_ModelIDName[12:26]:                  BarPathTracker,
	strings.ToLower(_ModelIDName[12:26]): BarPathTracker,
	_ModelIDName[26:37]:                  BarPathCalc,
	strings.ToLower(_ModelIDName[26:37]): BarPathCalc,
}

// ParseModelID attempts to convert a string to a ModelID.
func ParseModelID(name string) (ModelID, error) {
	if x, ok := _ModelIDValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ModelIDValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ModelID(0), fmt.Errorf("%s is %w", name, ErrInvalidModelID)
}

// MarshalText implements the text marshaller method.
func (x ModelID) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ModelID) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseModelID(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ModelID) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
