// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package types

import (
	"fmt"
	"strings"
)

const (
	// SecondOrder is a ApproximationError of type SecondOrder.
	SecondOrder ApproximationError = iota + 2
	// FourthOrder is a ApproximationError of type FourthOrder.
	FourthOrder ApproximationError = iota + 3
)

var ErrInvalidApproximationError = fmt.Errorf("not a valid ApproximationError, try [%s]", strings.Join(_ApproximationErrorNames, ", "))

const _ApproximationErrorName = "SecondOrderFourthOrder"

var _ApproximationErrorNames = []string{
	_ApproximationErrorName[0:11],
	_ApproximationErrorName[11:22],
}

// ApproximationErrorNames returns a list of possible string values of ApproximationError.
func ApproximationErrorNames() []string {
	tmp := make([]string, len(_ApproximationErrorNames))
	copy(tmp, _ApproximationErrorNames)
	return tmp
}

// ApproximationErrorValues returns a list of the values for ApproximationError
func ApproximationErrorValues() []ApproximationError {
	return []ApproximationError{
		SecondOrder,
		FourthOrder,
	}
}

var _ApproximationErrorMap = map[ApproximationError]string{
	SecondOrder: _ApproximationErrorName[0:11],
	FourthOrder: _ApproximationErrorName[11:22],
}

// String implements the Stringer interface.
func (x ApproximationError) String() string {
	if str, ok := _ApproximationErrorMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ApproximationError(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ApproximationError) IsValid() bool {
	_, ok := _ApproximationErrorMap[x]
	return ok
}

var _ApproximationErrorValue = map[string]ApproximationError{
	_ApproximationErrorName[0:11]:                   SecondOrder,
	strings.ToLower(_ApproximationErrorName[0:11]):  SecondOrder,
	_ApproximationErrorName[11:22]:                  FourthOrder,
	strings.ToLower(_ApproximationErrorName[11:22]): FourthOrder,
}

// ParseApproximationError attempts to convert a string to a ApproximationError.
func ParseApproximationError(name string) (ApproximationError, error) {
	if x, ok := _ApproximationErrorValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ApproximationErrorValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ApproximationError(0), fmt.Errorf("%s is %w", name, ErrInvalidApproximationError)
}

// MarshalText implements the text marshaller method.
func (x ApproximationError) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ApproximationError) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseApproximationError(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ApproximationError) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// UnknownExerciseFocus is a ExerciseFocus of type UnknownExerciseFocus.
	UnknownExerciseFocus ExerciseFocus = iota
	// Squat is a ExerciseFocus of type Squat.
	Squat
	// Bench is a ExerciseFocus of type Bench.
	Bench
	// Deadlift is a ExerciseFocus of type Deadlift.
	Deadlift
)

var ErrInvalidExerciseFocus = fmt.Errorf("not a valid ExerciseFocus, try [%s]", strings.Join(_ExerciseFocusNames, ", "))

const _ExerciseFocusName = "UnknownExerciseFocusSquatBenchDeadlift"

var _ExerciseFocusNames = []string{
	_ExerciseFocusName[0:20],
	_ExerciseFocusName[20:25],
	_ExerciseFocusName[25:30],
	_ExerciseFocusName[30:38],
}

// ExerciseFocusNames returns a list of possible string values of ExerciseFocus.
func ExerciseFocusNames() []string {
	tmp := make([]string, len(_ExerciseFocusNames))
	copy(tmp, _ExerciseFocusNames)
	return tmp
}

// ExerciseFocusValues returns a list of the values for ExerciseFocus
func ExerciseFocusValues() []ExerciseFocus {
	return []ExerciseFocus{
		UnknownExerciseFocus,
		Squat,
		Bench,
		Deadlift,
	}
}

var _ExerciseFocusMap = map[ExerciseFocus]string{
	UnknownExerciseFocus: _ExerciseFocusName[0:20],
	Squat:                _ExerciseFocusName[20:25],
	Bench:                _ExerciseFocusName[25:30],
	Deadlift:             _ExerciseFocusName[30:38],
}

// String implements the Stringer interface.
func (x ExerciseFocus) String() string {
	if str, ok := _ExerciseFocusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExerciseFocus(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExerciseFocus) IsValid() bool {
	_, ok := _ExerciseFocusMap[x]
	return ok
}

var _ExerciseFocusValue = map[string]ExerciseFocus{
	_ExerciseFocusName[0:20]:                   UnknownExerciseFocus,
	strings.ToLower(_ExerciseFocusName[0:20]):  UnknownExerciseFocus,
	_ExerciseFocusName[20:25]:                  Squat,
	strings.ToLower(_ExerciseFocusName[20:25]): Squat,
	_ExerciseFocusName[25:30]:                  Bench,
	strings.ToLower(_ExerciseFocusName[25:30]): Bench,
	_ExerciseFocusName[30:38]:                  Deadlift,
	strings.ToLower(_ExerciseFocusName[30:38]): Deadlift,
}

// ParseExerciseFocus attempts to convert a string to a ExerciseFocus.
func ParseExerciseFocus(name string) (ExerciseFocus, error) {
	if x, ok := _ExerciseFocusValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ExerciseFocusValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ExerciseFocus(0), fmt.Errorf("%s is %w", name, ErrInvalidExerciseFocus)
}

// MarshalText implements the text marshaller method.
func (x ExerciseFocus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ExerciseFocus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseExerciseFocus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ExerciseFocus) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// MainCompound is a ExerciseKind of type MainCompound.
	MainCompound ExerciseKind = iota + 1
	// MainCompoundAccessory is a ExerciseKind of type MainCompoundAccessory.
	MainCompoundAccessory
	// CompoundAccessory is a ExerciseKind of type CompoundAccessory.
	CompoundAccessory
	// Accessory is a ExerciseKind of type Accessory.
	Accessory
)

var ErrInvalidExerciseKind = fmt.Errorf("not a valid ExerciseKind, try [%s]", strings.Join(_ExerciseKindNames, ", "))

const _ExerciseKindName = "MainCompoundMainCompoundAccessoryCompoundAccessoryAccessory"

var _ExerciseKindNames = []string{
	_ExerciseKindName[0:12],
	_ExerciseKindName[12:33],
	_ExerciseKindName[33:50],
	_ExerciseKindName[50:59],
}

// ExerciseKindNames returns a list of possible string values of ExerciseKind.
func ExerciseKindNames() []string {
	tmp := make([]string, len(_ExerciseKindNames))
	copy(tmp, _ExerciseKindNames)
	return tmp
}

// ExerciseKindValues returns a list of the values for ExerciseKind
func ExerciseKindValues() []ExerciseKind {
	return []ExerciseKind{
		MainCompound,
		MainCompoundAccessory,
		CompoundAccessory,
		Accessory,
	}
}

var _ExerciseKindMap = map[ExerciseKind]string{
	MainCompound:          _ExerciseKindName[0:12],
	MainCompoundAccessory: _ExerciseKindName[12:33],
	CompoundAccessory:     _ExerciseKindName[33:50],
	Accessory:             _ExerciseKindName[50:59],
}

// String implements the Stringer interface.
func (x ExerciseKind) String() string {
	if str, ok := _ExerciseKindMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExerciseKind(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExerciseKind) IsValid() bool {
	_, ok := _ExerciseKindMap[x]
	return ok
}

var _ExerciseKindValue = map[string]ExerciseKind{
	_ExerciseKindName[0:12]:                   MainCompound,
	strings.ToLower(_ExerciseKindName[0:12]):  MainCompound,
	_ExerciseKindName[12:33]:                  MainCompoundAccessory,
	strings.ToLower(_ExerciseKindName[12:33]): MainCompoundAccessory,
	_ExerciseKindName[33:50]:                  CompoundAccessory,
	strings.ToLower(_ExerciseKindName[33:50]): CompoundAccessory,
	_ExerciseKindName[50:59]:                  Accessory,
	strings.ToLower(_ExerciseKindName[50:59]): Accessory,
}

// ParseExerciseKind attempts to convert a string to a ExerciseKind.
func ParseExerciseKind(name string) (ExerciseKind, error) {
	if x, ok := _ExerciseKindValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ExerciseKindValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ExerciseKind(0), fmt.Errorf("%s is %w", name, ErrInvalidExerciseKind)
}

// MarshalText implements the text marshaller method.
func (x ExerciseKind) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ExerciseKind) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseExerciseKind(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ExerciseKind) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// UnknownModel is a ModelID of type UnknownModel.
	UnknownModel ModelID = iota
	// SimplifiedNegativeSpace is a ModelID of type SimplifiedNegativeSpace.
	SimplifiedNegativeSpace
)

var ErrInvalidModelID = fmt.Errorf("not a valid ModelID, try [%s]", strings.Join(_ModelIDNames, ", "))

const _ModelIDName = "UnknownModelSimplifiedNegativeSpace"

var _ModelIDNames = []string{
	_ModelIDName[0:12],
	_ModelIDName[12:35],
}

// ModelIDNames returns a list of possible string values of ModelID.
func ModelIDNames() []string {
	tmp := make([]string, len(_ModelIDNames))
	copy(tmp, _ModelIDNames)
	return tmp
}

// ModelIDValues returns a list of the values for ModelID
func ModelIDValues() []ModelID {
	return []ModelID{
		UnknownModel,
		SimplifiedNegativeSpace,
	}
}

var _ModelIDMap = map[ModelID]string{
	UnknownModel:            _ModelIDName[0:12],
	SimplifiedNegativeSpace: _ModelIDName[12:35],
}

// String implements the Stringer interface.
func (x ModelID) String() string {
	if str, ok := _ModelIDMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ModelID(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ModelID) IsValid() bool {
	_, ok := _ModelIDMap[x]
	return ok
}

var _ModelIDValue = map[string]ModelID{
	_ModelIDName[0:12]:                   UnknownModel,
	strings.ToLower(_ModelIDName[0:12]):  UnknownModel,
	_ModelIDName[12:35]:                  SimplifiedNegativeSpace,
	strings.ToLower(_ModelIDName[12:35]): SimplifiedNegativeSpace,
}

// ParseModelID attempts to convert a string to a ModelID.
func ParseModelID(name string) (ModelID, error) {
	if x, ok := _ModelIDValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ModelIDValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ModelID(0), fmt.Errorf("%s is %w", name, ErrInvalidModelID)
}

// MarshalText implements the text marshaller method.
func (x ModelID) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ModelID) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseModelID(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ModelID) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
