// Code generated by go-enum DO NOT EDIT.
// Version: 0.6.1
// Revision: a6f63bddde05aca4221df9c8e9e6d7d9674b1cb4
// Build Date: 2025-03-18T23:42:14Z
// Built By: goreleaser

package types

import (
	"fmt"
	"strings"
)

const (
	// UnknownExerciseFocus is a ExerciseFocus of type UnknownExerciseFocus.
	UnknownExerciseFocus ExerciseFocus = iota
	// Squat is a ExerciseFocus of type Squat.
	Squat
	// Bench is a ExerciseFocus of type Bench.
	Bench
	// Deadlift is a ExerciseFocus of type Deadlift.
	Deadlift
)

var ErrInvalidExerciseFocus = fmt.Errorf("not a valid ExerciseFocus, try [%s]", strings.Join(_ExerciseFocusNames, ", "))

const _ExerciseFocusName = "UnknownExerciseFocusSquatBenchDeadlift"

var _ExerciseFocusNames = []string{
	_ExerciseFocusName[0:20],
	_ExerciseFocusName[20:25],
	_ExerciseFocusName[25:30],
	_ExerciseFocusName[30:38],
}

// ExerciseFocusNames returns a list of possible string values of ExerciseFocus.
func ExerciseFocusNames() []string {
	tmp := make([]string, len(_ExerciseFocusNames))
	copy(tmp, _ExerciseFocusNames)
	return tmp
}

// ExerciseFocusValues returns a list of the values for ExerciseFocus
func ExerciseFocusValues() []ExerciseFocus {
	return []ExerciseFocus{
		UnknownExerciseFocus,
		Squat,
		Bench,
		Deadlift,
	}
}

var _ExerciseFocusMap = map[ExerciseFocus]string{
	UnknownExerciseFocus: _ExerciseFocusName[0:20],
	Squat:                _ExerciseFocusName[20:25],
	Bench:                _ExerciseFocusName[25:30],
	Deadlift:             _ExerciseFocusName[30:38],
}

// String implements the Stringer interface.
func (x ExerciseFocus) String() string {
	if str, ok := _ExerciseFocusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExerciseFocus(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExerciseFocus) IsValid() bool {
	_, ok := _ExerciseFocusMap[x]
	return ok
}

var _ExerciseFocusValue = map[string]ExerciseFocus{
	_ExerciseFocusName[0:20]:                   UnknownExerciseFocus,
	strings.ToLower(_ExerciseFocusName[0:20]):  UnknownExerciseFocus,
	_ExerciseFocusName[20:25]:                  Squat,
	strings.ToLower(_ExerciseFocusName[20:25]): Squat,
	_ExerciseFocusName[25:30]:                  Bench,
	strings.ToLower(_ExerciseFocusName[25:30]): Bench,
	_ExerciseFocusName[30:38]:                  Deadlift,
	strings.ToLower(_ExerciseFocusName[30:38]): Deadlift,
}

// ParseExerciseFocus attempts to convert a string to a ExerciseFocus.
func ParseExerciseFocus(name string) (ExerciseFocus, error) {
	if x, ok := _ExerciseFocusValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ExerciseFocusValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ExerciseFocus(0), fmt.Errorf("%s is %w", name, ErrInvalidExerciseFocus)
}

// MarshalText implements the text marshaller method.
func (x ExerciseFocus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ExerciseFocus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseExerciseFocus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// MainCompound is a ExerciseKind of type MainCompound.
	MainCompound ExerciseKind = iota + 1
	// MainCompoundAccessory is a ExerciseKind of type MainCompoundAccessory.
	MainCompoundAccessory
	// CompoundAccessory is a ExerciseKind of type CompoundAccessory.
	CompoundAccessory
	// Accessory is a ExerciseKind of type Accessory.
	Accessory
)

var ErrInvalidExerciseKind = fmt.Errorf("not a valid ExerciseKind, try [%s]", strings.Join(_ExerciseKindNames, ", "))

const _ExerciseKindName = "MainCompoundMainCompoundAccessoryCompoundAccessoryAccessory"

var _ExerciseKindNames = []string{
	_ExerciseKindName[0:12],
	_ExerciseKindName[12:33],
	_ExerciseKindName[33:50],
	_ExerciseKindName[50:59],
}

// ExerciseKindNames returns a list of possible string values of ExerciseKind.
func ExerciseKindNames() []string {
	tmp := make([]string, len(_ExerciseKindNames))
	copy(tmp, _ExerciseKindNames)
	return tmp
}

// ExerciseKindValues returns a list of the values for ExerciseKind
func ExerciseKindValues() []ExerciseKind {
	return []ExerciseKind{
		MainCompound,
		MainCompoundAccessory,
		CompoundAccessory,
		Accessory,
	}
}

var _ExerciseKindMap = map[ExerciseKind]string{
	MainCompound:          _ExerciseKindName[0:12],
	MainCompoundAccessory: _ExerciseKindName[12:33],
	CompoundAccessory:     _ExerciseKindName[33:50],
	Accessory:             _ExerciseKindName[50:59],
}

// String implements the Stringer interface.
func (x ExerciseKind) String() string {
	if str, ok := _ExerciseKindMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExerciseKind(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExerciseKind) IsValid() bool {
	_, ok := _ExerciseKindMap[x]
	return ok
}

var _ExerciseKindValue = map[string]ExerciseKind{
	_ExerciseKindName[0:12]:                   MainCompound,
	strings.ToLower(_ExerciseKindName[0:12]):  MainCompound,
	_ExerciseKindName[12:33]:                  MainCompoundAccessory,
	strings.ToLower(_ExerciseKindName[12:33]): MainCompoundAccessory,
	_ExerciseKindName[33:50]:                  CompoundAccessory,
	strings.ToLower(_ExerciseKindName[33:50]): CompoundAccessory,
	_ExerciseKindName[50:59]:                  Accessory,
	strings.ToLower(_ExerciseKindName[50:59]): Accessory,
}

// ParseExerciseKind attempts to convert a string to a ExerciseKind.
func ParseExerciseKind(name string) (ExerciseKind, error) {
	if x, ok := _ExerciseKindValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ExerciseKindValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ExerciseKind(0), fmt.Errorf("%s is %w", name, ErrInvalidExerciseKind)
}

// MarshalText implements the text marshaller method.
func (x ExerciseKind) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ExerciseKind) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseExerciseKind(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// UnknownModel is a ModelID of type UnknownModel.
	UnknownModel ModelID = iota
	// SimplifiedNegativeSpace is a ModelID of type SimplifiedNegativeSpace.
	SimplifiedNegativeSpace
)

var ErrInvalidModelID = fmt.Errorf("not a valid ModelID, try [%s]", strings.Join(_ModelIDNames, ", "))

const _ModelIDName = "UnknownModelSimplifiedNegativeSpace"

var _ModelIDNames = []string{
	_ModelIDName[0:12],
	_ModelIDName[12:35],
}

// ModelIDNames returns a list of possible string values of ModelID.
func ModelIDNames() []string {
	tmp := make([]string, len(_ModelIDNames))
	copy(tmp, _ModelIDNames)
	return tmp
}

// ModelIDValues returns a list of the values for ModelID
func ModelIDValues() []ModelID {
	return []ModelID{
		UnknownModel,
		SimplifiedNegativeSpace,
	}
}

var _ModelIDMap = map[ModelID]string{
	UnknownModel:            _ModelIDName[0:12],
	SimplifiedNegativeSpace: _ModelIDName[12:35],
}

// String implements the Stringer interface.
func (x ModelID) String() string {
	if str, ok := _ModelIDMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ModelID(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ModelID) IsValid() bool {
	_, ok := _ModelIDMap[x]
	return ok
}

var _ModelIDValue = map[string]ModelID{
	_ModelIDName[0:12]:                   UnknownModel,
	strings.ToLower(_ModelIDName[0:12]):  UnknownModel,
	_ModelIDName[12:35]:                  SimplifiedNegativeSpace,
	strings.ToLower(_ModelIDName[12:35]): SimplifiedNegativeSpace,
}

// ParseModelID attempts to convert a string to a ModelID.
func ParseModelID(name string) (ModelID, error) {
	if x, ok := _ModelIDValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ModelIDValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ModelID(0), fmt.Errorf("%s is %w", name, ErrInvalidModelID)
}

// MarshalText implements the text marshaller method.
func (x ModelID) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ModelID) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseModelID(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
