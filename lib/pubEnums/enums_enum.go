// Code generated by go-enum DO NOT EDIT.
// Version: 0.6.1
// Revision: a6f63bddde05aca4221df9c8e9e6d7d9674b1cb4
// Build Date: 2025-03-18T23:42:14Z
// Built By: goreleaser

package pubenums

import (
	"fmt"
	"strings"
)

const (
	// ExerciseFocusUnknown is a ExerciseFocus of type Unknown.
	ExerciseFocusUnknown ExerciseFocus = iota
	// ExerciseFocusSquat is a ExerciseFocus of type Squat.
	ExerciseFocusSquat
	// ExerciseFocusBench is a ExerciseFocus of type Bench.
	ExerciseFocusBench
	// ExerciseFocusDeadlift is a ExerciseFocus of type Deadlift.
	ExerciseFocusDeadlift
)

var ErrInvalidExerciseFocus = fmt.Errorf("not a valid ExerciseFocus, try [%s]", strings.Join(_ExerciseFocusNames, ", "))

const _ExerciseFocusName = "UnknownSquatBenchDeadlift"

var _ExerciseFocusNames = []string{
	_ExerciseFocusName[0:7],
	_ExerciseFocusName[7:12],
	_ExerciseFocusName[12:17],
	_ExerciseFocusName[17:25],
}

// ExerciseFocusNames returns a list of possible string values of ExerciseFocus.
func ExerciseFocusNames() []string {
	tmp := make([]string, len(_ExerciseFocusNames))
	copy(tmp, _ExerciseFocusNames)
	return tmp
}

// ExerciseFocusValues returns a list of the values for ExerciseFocus
func ExerciseFocusValues() []ExerciseFocus {
	return []ExerciseFocus{
		ExerciseFocusUnknown,
		ExerciseFocusSquat,
		ExerciseFocusBench,
		ExerciseFocusDeadlift,
	}
}

var _ExerciseFocusMap = map[ExerciseFocus]string{
	ExerciseFocusUnknown:  _ExerciseFocusName[0:7],
	ExerciseFocusSquat:    _ExerciseFocusName[7:12],
	ExerciseFocusBench:    _ExerciseFocusName[12:17],
	ExerciseFocusDeadlift: _ExerciseFocusName[17:25],
}

// String implements the Stringer interface.
func (x ExerciseFocus) String() string {
	if str, ok := _ExerciseFocusMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExerciseFocus(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExerciseFocus) IsValid() bool {
	_, ok := _ExerciseFocusMap[x]
	return ok
}

var _ExerciseFocusValue = map[string]ExerciseFocus{
	_ExerciseFocusName[0:7]:                    ExerciseFocusUnknown,
	strings.ToLower(_ExerciseFocusName[0:7]):   ExerciseFocusUnknown,
	_ExerciseFocusName[7:12]:                   ExerciseFocusSquat,
	strings.ToLower(_ExerciseFocusName[7:12]):  ExerciseFocusSquat,
	_ExerciseFocusName[12:17]:                  ExerciseFocusBench,
	strings.ToLower(_ExerciseFocusName[12:17]): ExerciseFocusBench,
	_ExerciseFocusName[17:25]:                  ExerciseFocusDeadlift,
	strings.ToLower(_ExerciseFocusName[17:25]): ExerciseFocusDeadlift,
}

// ParseExerciseFocus attempts to convert a string to a ExerciseFocus.
func ParseExerciseFocus(name string) (ExerciseFocus, error) {
	if x, ok := _ExerciseFocusValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ExerciseFocusValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ExerciseFocus(0), fmt.Errorf("%s is %w", name, ErrInvalidExerciseFocus)
}

// MarshalText implements the text marshaller method.
func (x ExerciseFocus) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ExerciseFocus) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseExerciseFocus(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ExerciseKindUnknown is a ExerciseKind of type Unknown.
	ExerciseKindUnknown ExerciseKind = iota
	// ExerciseKindMainCompound is a ExerciseKind of type MainCompound.
	ExerciseKindMainCompound
	// ExerciseKindMainCompoundAccessory is a ExerciseKind of type MainCompoundAccessory.
	ExerciseKindMainCompoundAccessory
	// ExerciseKindCompoundAccessory is a ExerciseKind of type CompoundAccessory.
	ExerciseKindCompoundAccessory
	// ExerciseKindAccessory is a ExerciseKind of type Accessory.
	ExerciseKindAccessory
)

var ErrInvalidExerciseKind = fmt.Errorf("not a valid ExerciseKind, try [%s]", strings.Join(_ExerciseKindNames, ", "))

const _ExerciseKindName = "UnknownMainCompoundMainCompoundAccessoryCompoundAccessoryAccessory"

var _ExerciseKindNames = []string{
	_ExerciseKindName[0:7],
	_ExerciseKindName[7:19],
	_ExerciseKindName[19:40],
	_ExerciseKindName[40:57],
	_ExerciseKindName[57:66],
}

// ExerciseKindNames returns a list of possible string values of ExerciseKind.
func ExerciseKindNames() []string {
	tmp := make([]string, len(_ExerciseKindNames))
	copy(tmp, _ExerciseKindNames)
	return tmp
}

// ExerciseKindValues returns a list of the values for ExerciseKind
func ExerciseKindValues() []ExerciseKind {
	return []ExerciseKind{
		ExerciseKindUnknown,
		ExerciseKindMainCompound,
		ExerciseKindMainCompoundAccessory,
		ExerciseKindCompoundAccessory,
		ExerciseKindAccessory,
	}
}

var _ExerciseKindMap = map[ExerciseKind]string{
	ExerciseKindUnknown:               _ExerciseKindName[0:7],
	ExerciseKindMainCompound:          _ExerciseKindName[7:19],
	ExerciseKindMainCompoundAccessory: _ExerciseKindName[19:40],
	ExerciseKindCompoundAccessory:     _ExerciseKindName[40:57],
	ExerciseKindAccessory:             _ExerciseKindName[57:66],
}

// String implements the Stringer interface.
func (x ExerciseKind) String() string {
	if str, ok := _ExerciseKindMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ExerciseKind(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ExerciseKind) IsValid() bool {
	_, ok := _ExerciseKindMap[x]
	return ok
}

var _ExerciseKindValue = map[string]ExerciseKind{
	_ExerciseKindName[0:7]:                    ExerciseKindUnknown,
	strings.ToLower(_ExerciseKindName[0:7]):   ExerciseKindUnknown,
	_ExerciseKindName[7:19]:                   ExerciseKindMainCompound,
	strings.ToLower(_ExerciseKindName[7:19]):  ExerciseKindMainCompound,
	_ExerciseKindName[19:40]:                  ExerciseKindMainCompoundAccessory,
	strings.ToLower(_ExerciseKindName[19:40]): ExerciseKindMainCompoundAccessory,
	_ExerciseKindName[40:57]:                  ExerciseKindCompoundAccessory,
	strings.ToLower(_ExerciseKindName[40:57]): ExerciseKindCompoundAccessory,
	_ExerciseKindName[57:66]:                  ExerciseKindAccessory,
	strings.ToLower(_ExerciseKindName[57:66]): ExerciseKindAccessory,
}

// ParseExerciseKind attempts to convert a string to a ExerciseKind.
func ParseExerciseKind(name string) (ExerciseKind, error) {
	if x, ok := _ExerciseKindValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ExerciseKindValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ExerciseKind(0), fmt.Errorf("%s is %w", name, ErrInvalidExerciseKind)
}

// MarshalText implements the text marshaller method.
func (x ExerciseKind) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ExerciseKind) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseExerciseKind(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// ModelIDUnknown is a ModelID of type Unknown.
	ModelIDUnknown ModelID = iota
	// ModelIDSimplifiedNegativeSpace is a ModelID of type SimplifiedNegativeSpace.
	ModelIDSimplifiedNegativeSpace
)

var ErrInvalidModelID = fmt.Errorf("not a valid ModelID, try [%s]", strings.Join(_ModelIDNames, ", "))

const _ModelIDName = "UnknownSimplifiedNegativeSpace"

var _ModelIDNames = []string{
	_ModelIDName[0:7],
	_ModelIDName[7:30],
}

// ModelIDNames returns a list of possible string values of ModelID.
func ModelIDNames() []string {
	tmp := make([]string, len(_ModelIDNames))
	copy(tmp, _ModelIDNames)
	return tmp
}

// ModelIDValues returns a list of the values for ModelID
func ModelIDValues() []ModelID {
	return []ModelID{
		ModelIDUnknown,
		ModelIDSimplifiedNegativeSpace,
	}
}

var _ModelIDMap = map[ModelID]string{
	ModelIDUnknown:                 _ModelIDName[0:7],
	ModelIDSimplifiedNegativeSpace: _ModelIDName[7:30],
}

// String implements the Stringer interface.
func (x ModelID) String() string {
	if str, ok := _ModelIDMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ModelID(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ModelID) IsValid() bool {
	_, ok := _ModelIDMap[x]
	return ok
}

var _ModelIDValue = map[string]ModelID{
	_ModelIDName[0:7]:                   ModelIDUnknown,
	strings.ToLower(_ModelIDName[0:7]):  ModelIDUnknown,
	_ModelIDName[7:30]:                  ModelIDSimplifiedNegativeSpace,
	strings.ToLower(_ModelIDName[7:30]): ModelIDSimplifiedNegativeSpace,
}

// ParseModelID attempts to convert a string to a ModelID.
func ParseModelID(name string) (ModelID, error) {
	if x, ok := _ModelIDValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ModelIDValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ModelID(0), fmt.Errorf("%s is %w", name, ErrInvalidModelID)
}

// MarshalText implements the text marshaller method.
func (x ModelID) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ModelID) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseModelID(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
