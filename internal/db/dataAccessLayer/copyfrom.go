// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package dal

import (
	"context"
)

// iteratorForBulkCreateClients implements pgx.CopyFromSource.
type iteratorForBulkCreateClients struct {
	rows                 []BulkCreateClientsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateClients) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateClients) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].FirstName,
		r.rows[0].LastName,
		r.rows[0].Email,
	}, nil
}

func (r iteratorForBulkCreateClients) Err() error {
	return nil
}

func (q *Queries) BulkCreateClients(ctx context.Context, arg []BulkCreateClientsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "client"}, []string{"first_name", "last_name", "email"}, &iteratorForBulkCreateClients{rows: arg})
}

// iteratorForBulkCreateExerciseFocusWithID implements pgx.CopyFromSource.
type iteratorForBulkCreateExerciseFocusWithID struct {
	rows                 []BulkCreateExerciseFocusWithIDParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateExerciseFocusWithID) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateExerciseFocusWithID) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Focus,
	}, nil
}

func (r iteratorForBulkCreateExerciseFocusWithID) Err() error {
	return nil
}

func (q *Queries) BulkCreateExerciseFocusWithID(ctx context.Context, arg []BulkCreateExerciseFocusWithIDParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "exercise_focus"}, []string{"id", "focus"}, &iteratorForBulkCreateExerciseFocusWithID{rows: arg})
}

// iteratorForBulkCreateExerciseKindWithID implements pgx.CopyFromSource.
type iteratorForBulkCreateExerciseKindWithID struct {
	rows                 []BulkCreateExerciseKindWithIDParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateExerciseKindWithID) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateExerciseKindWithID) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Kind,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForBulkCreateExerciseKindWithID) Err() error {
	return nil
}

func (q *Queries) BulkCreateExerciseKindWithID(ctx context.Context, arg []BulkCreateExerciseKindWithIDParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "exercise_kind"}, []string{"id", "kind", "description"}, &iteratorForBulkCreateExerciseKindWithID{rows: arg})
}

// iteratorForBulkCreateExerciseWithID implements pgx.CopyFromSource.
type iteratorForBulkCreateExerciseWithID struct {
	rows                 []BulkCreateExerciseWithIDParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateExerciseWithID) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateExerciseWithID) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Name,
		r.rows[0].KindID,
		r.rows[0].FocusID,
	}, nil
}

func (r iteratorForBulkCreateExerciseWithID) Err() error {
	return nil
}

func (q *Queries) BulkCreateExerciseWithID(ctx context.Context, arg []BulkCreateExerciseWithIDParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "exercise"}, []string{"id", "name", "kind_id", "focus_id"}, &iteratorForBulkCreateExerciseWithID{rows: arg})
}

// iteratorForBulkCreateModelStates implements pgx.CopyFromSource.
type iteratorForBulkCreateModelStates struct {
	rows                 []BulkCreateModelStatesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateModelStates) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateModelStates) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ClientID,
		r.rows[0].TrainingLogID,
		r.rows[0].ModelID,
		r.rows[0].V1,
		r.rows[0].V2,
		r.rows[0].V3,
		r.rows[0].V4,
		r.rows[0].V5,
		r.rows[0].V6,
		r.rows[0].V7,
		r.rows[0].V8,
		r.rows[0].V9,
		r.rows[0].V10,
		r.rows[0].TimeFrame,
		r.rows[0].Mse,
		r.rows[0].PredWeight,
	}, nil
}

func (r iteratorForBulkCreateModelStates) Err() error {
	return nil
}

func (q *Queries) BulkCreateModelStates(ctx context.Context, arg []BulkCreateModelStatesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "model_state"}, []string{"client_id", "training_log_id", "model_id", "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v10", "time_frame", "mse", "pred_weight"}, &iteratorForBulkCreateModelStates{rows: arg})
}

// iteratorForBulkCreateModels implements pgx.CopyFromSource.
type iteratorForBulkCreateModels struct {
	rows                 []BulkCreateModelsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateModels) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateModels) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Name,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForBulkCreateModels) Err() error {
	return nil
}

func (q *Queries) BulkCreateModels(ctx context.Context, arg []BulkCreateModelsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "model"}, []string{"id", "name", "description"}, &iteratorForBulkCreateModels{rows: arg})
}

// iteratorForBulkCreateTraingLog implements pgx.CopyFromSource.
type iteratorForBulkCreateTraingLog struct {
	rows                 []BulkCreateTraingLogParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateTraingLog) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateTraingLog) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ExerciseID,
		r.rows[0].ExerciseKindID,
		r.rows[0].ExerciseFocusID,
		r.rows[0].ClientID,
		r.rows[0].VideoID,
		r.rows[0].DatePerformed,
		r.rows[0].Weight,
		r.rows[0].Sets,
		r.rows[0].Reps,
		r.rows[0].Effort,
		r.rows[0].InterSessionCntr,
		r.rows[0].InterWorkoutCntr,
	}, nil
}

func (r iteratorForBulkCreateTraingLog) Err() error {
	return nil
}

func (q *Queries) BulkCreateTraingLog(ctx context.Context, arg []BulkCreateTraingLogParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "training_log"}, []string{"exercise_id", "exercise_kind_id", "exercise_focus_id", "client_id", "video_id", "date_performed", "weight", "sets", "reps", "effort", "inter_session_cntr", "inter_workout_cntr"}, &iteratorForBulkCreateTraingLog{rows: arg})
}

// iteratorForBulkCreateVideoDataWithID implements pgx.CopyFromSource.
type iteratorForBulkCreateVideoDataWithID struct {
	rows                 []BulkCreateVideoDataWithIDParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateVideoDataWithID) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateVideoDataWithID) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Path,
		r.rows[0].Position,
		r.rows[0].Velocity,
		r.rows[0].Acceleration,
		r.rows[0].Force,
		r.rows[0].Impulse,
	}, nil
}

func (r iteratorForBulkCreateVideoDataWithID) Err() error {
	return nil
}

func (q *Queries) BulkCreateVideoDataWithID(ctx context.Context, arg []BulkCreateVideoDataWithIDParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "video_data"}, []string{"id", "path", "position", "velocity", "acceleration", "force", "impulse"}, &iteratorForBulkCreateVideoDataWithID{rows: arg})
}
