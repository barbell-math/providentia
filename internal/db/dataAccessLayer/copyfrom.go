// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package dal

import (
	"context"
)

// iteratorForBulkCreateClients implements pgx.CopyFromSource.
type iteratorForBulkCreateClients struct {
	rows                 []BulkCreateClientsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateClients) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateClients) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].FirstName,
		r.rows[0].LastName,
		r.rows[0].Email,
	}, nil
}

func (r iteratorForBulkCreateClients) Err() error {
	return nil
}

func (q *Queries) BulkCreateClients(ctx context.Context, arg []BulkCreateClientsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "client"}, []string{"first_name", "last_name", "email"}, &iteratorForBulkCreateClients{rows: arg})
}

// iteratorForBulkCreateExerciseFocusWithID implements pgx.CopyFromSource.
type iteratorForBulkCreateExerciseFocusWithID struct {
	rows                 []BulkCreateExerciseFocusWithIDParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateExerciseFocusWithID) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateExerciseFocusWithID) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Focus,
	}, nil
}

func (r iteratorForBulkCreateExerciseFocusWithID) Err() error {
	return nil
}

// This query is used for initilization by the migrations. The
// UpdateExerciseFocusSerialCount query will need to be run after this to update
// the serial counter.
func (q *Queries) BulkCreateExerciseFocusWithID(ctx context.Context, arg []BulkCreateExerciseFocusWithIDParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "exercise_focus"}, []string{"id", "focus"}, &iteratorForBulkCreateExerciseFocusWithID{rows: arg})
}

// iteratorForBulkCreateExerciseKindWithID implements pgx.CopyFromSource.
type iteratorForBulkCreateExerciseKindWithID struct {
	rows                 []BulkCreateExerciseKindWithIDParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateExerciseKindWithID) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateExerciseKindWithID) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Kind,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForBulkCreateExerciseKindWithID) Err() error {
	return nil
}

// This query is used for initilization by the migrations. The
// UpdateExerciseKindSerialCount query will need to be run after this to update
// the serial counter.
func (q *Queries) BulkCreateExerciseKindWithID(ctx context.Context, arg []BulkCreateExerciseKindWithIDParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "exercise_kind"}, []string{"id", "kind", "description"}, &iteratorForBulkCreateExerciseKindWithID{rows: arg})
}

// iteratorForBulkCreateExerciseWithID implements pgx.CopyFromSource.
type iteratorForBulkCreateExerciseWithID struct {
	rows                 []BulkCreateExerciseWithIDParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateExerciseWithID) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateExerciseWithID) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Name,
		r.rows[0].KindID,
		r.rows[0].FocusID,
	}, nil
}

func (r iteratorForBulkCreateExerciseWithID) Err() error {
	return nil
}

// This query is used for initilization by the migrations. The
// UpdateExerciseSerialCount query will need to be run after this to update
// the serial counter.
func (q *Queries) BulkCreateExerciseWithID(ctx context.Context, arg []BulkCreateExerciseWithIDParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "exercise"}, []string{"id", "name", "kind_id", "focus_id"}, &iteratorForBulkCreateExerciseWithID{rows: arg})
}

// iteratorForBulkCreateExercises implements pgx.CopyFromSource.
type iteratorForBulkCreateExercises struct {
	rows                 []BulkCreateExercisesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateExercises) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateExercises) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Name,
		r.rows[0].KindID,
		r.rows[0].FocusID,
	}, nil
}

func (r iteratorForBulkCreateExercises) Err() error {
	return nil
}

func (q *Queries) BulkCreateExercises(ctx context.Context, arg []BulkCreateExercisesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "exercise"}, []string{"name", "kind_id", "focus_id"}, &iteratorForBulkCreateExercises{rows: arg})
}

// iteratorForBulkCreateModelStates implements pgx.CopyFromSource.
type iteratorForBulkCreateModelStates struct {
	rows                 []BulkCreateModelStatesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateModelStates) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateModelStates) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ClientID,
		r.rows[0].TrainingLogID,
		r.rows[0].ModelID,
		r.rows[0].V1,
		r.rows[0].V2,
		r.rows[0].V3,
		r.rows[0].V4,
		r.rows[0].V5,
		r.rows[0].V6,
		r.rows[0].V7,
		r.rows[0].V8,
		r.rows[0].V9,
		r.rows[0].V10,
		r.rows[0].TimeFrame,
		r.rows[0].Mse,
		r.rows[0].PredWeight,
	}, nil
}

func (r iteratorForBulkCreateModelStates) Err() error {
	return nil
}

// --- OLD ----------------------------------------------------------------------
func (q *Queries) BulkCreateModelStates(ctx context.Context, arg []BulkCreateModelStatesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "model_state"}, []string{"client_id", "training_log_id", "model_id", "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8", "v9", "v10", "time_frame", "mse", "pred_weight"}, &iteratorForBulkCreateModelStates{rows: arg})
}

// iteratorForBulkCreateModelsWithID implements pgx.CopyFromSource.
type iteratorForBulkCreateModelsWithID struct {
	rows                 []BulkCreateModelsWithIDParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateModelsWithID) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateModelsWithID) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Name,
		r.rows[0].Description,
	}, nil
}

func (r iteratorForBulkCreateModelsWithID) Err() error {
	return nil
}

// This query is used for initilization by the migrations. The
// UpdateModelSerialCount query will need to be run after this to update
// the serial counter.
func (q *Queries) BulkCreateModelsWithID(ctx context.Context, arg []BulkCreateModelsWithIDParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "model"}, []string{"id", "name", "description"}, &iteratorForBulkCreateModelsWithID{rows: arg})
}

// iteratorForBulkCreateTrainingLogs implements pgx.CopyFromSource.
type iteratorForBulkCreateTrainingLogs struct {
	rows                 []BulkCreateTrainingLogsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateTrainingLogs) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateTrainingLogs) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ExerciseID,
		r.rows[0].ClientID,
		r.rows[0].PhysicsID,
		r.rows[0].DatePerformed,
		r.rows[0].Weight,
		r.rows[0].Sets,
		r.rows[0].Reps,
		r.rows[0].Effort,
		r.rows[0].InterSessionCntr,
		r.rows[0].InterWorkoutCntr,
	}, nil
}

func (r iteratorForBulkCreateTrainingLogs) Err() error {
	return nil
}

func (q *Queries) BulkCreateTrainingLogs(ctx context.Context, arg []BulkCreateTrainingLogsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"providentia", "training_log"}, []string{"exercise_id", "client_id", "physics_id", "date_performed", "weight", "sets", "reps", "effort", "inter_session_cntr", "inter_workout_cntr"}, &iteratorForBulkCreateTrainingLogs{rows: arg})
}
