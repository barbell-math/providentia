// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package dal

import (
	"context"

	"code.barbellmath.net/barbell-math/providentia/lib/types"
	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateClientsParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

type BulkCreateExerciseFocusWithIDParams struct {
	ID    types.ExerciseFocus `json:"id"`
	Focus string              `json:"focus"`
}

type BulkCreateExerciseKindWithIDParams struct {
	ID          types.ExerciseKind `json:"id"`
	Kind        string             `json:"kind"`
	Description string             `json:"description"`
}

type BulkCreateExerciseWithIDParams struct {
	ID      int32               `json:"id"`
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

type BulkCreateExercisesParams struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

type BulkCreateHyperparamsParams struct {
	ModelID types.ModelID `json:"model_id"`
	Version int32         `json:"version"`
	Params  []byte        `json:"params"`
}

type BulkCreateHyperparamsWithIDParams struct {
	ID      int32         `json:"id"`
	ModelID types.ModelID `json:"model_id"`
	Version int32         `json:"version"`
	Params  []byte        `json:"params"`
}

type BulkCreateModelsWithIDParams struct {
	ID          types.ModelID `json:"id"`
	Name        string        `json:"name"`
	Description string        `json:"description"`
}

type BulkCreateTrainingLogsParams struct {
	ExerciseID       int32          `json:"exercise_id"`
	ClientID         int64          `json:"client_id"`
	PhysicsID        pgtype.Int8    `json:"physics_id"`
	DatePerformed    pgtype.Date    `json:"date_performed"`
	Weight           types.Kilogram `json:"weight"`
	Sets             float64        `json:"sets"`
	Reps             int32          `json:"reps"`
	Effort           types.RPE      `json:"effort"`
	InterSessionCntr int16          `json:"inter_session_cntr"`
	InterWorkoutCntr int16          `json:"inter_workout_cntr"`
}

const clientExists = `-- name: ClientExists :one
SELECT EXISTS(SELECT 1 FROM providentia.client WHERE email = $1)
`

func (q *Queries) ClientExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, clientExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createPhysicsData = `-- name: CreatePhysicsData :one
INSERT INTO providentia.physics_data(
	path,
	bar_path_calc_id, bar_path_track_id,
	time, position, velocity, acceleration, jerk,
	force, impulse, work, power,
	rep_splits,
	min_vel, max_vel,
	min_acc, max_acc,
	min_force, max_force,
	min_impulse, max_impulse,
	avg_work, min_work, max_work,
	avg_power, min_power, max_power
) VALUES (
	$1,
	(
		SELECT providentia.model.id FROM providentia.hyperparams
		JOIN providentia.model
			ON providentia.model.id = providentia.hyperparams.model_id
		WHERE providentia.model.name='BarPathCalc'
			AND providentia.hyperparams.version=$26
	),
	(
		SELECT providentia.model.id FROM providentia.hyperparams
		JOIN providentia.model
			ON providentia.model.id = providentia.hyperparams.model_id
		WHERE providentia.model.name='BarPathTracker'
			AND providentia.hyperparams.version=$27
	),
	$2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
	$18, $19, $20, $21, $22, $23, $24, $25
) RETURNING id
`

type CreatePhysicsDataParams struct {
	Path                        []string                                                `json:"path"`
	Time                        [][]types.Second                                        `json:"time"`
	Position                    [][]types.Vec2[types.Meter, types.Meter]                `json:"position"`
	Velocity                    [][]types.Vec2[types.MeterPerSec, types.MeterPerSec]    `json:"velocity"`
	Acceleration                [][]types.Vec2[types.MeterPerSec2, types.MeterPerSec2]  `json:"acceleration"`
	Jerk                        [][]types.Vec2[types.MeterPerSec3, types.MeterPerSec3]  `json:"jerk"`
	Force                       [][]types.Vec2[types.Newton, types.Newton]              `json:"force"`
	Impulse                     [][]types.Vec2[types.NewtonSec, types.NewtonSec]        `json:"impulse"`
	Work                        [][]types.Joule                                         `json:"work"`
	Power                       [][]types.Watt                                          `json:"power"`
	RepSplits                   [][]types.Split                                         `json:"rep_splits"`
	MinVel                      [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"min_vel"`
	MaxVel                      [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"max_vel"`
	MinAcc                      [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"min_acc"`
	MaxAcc                      [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"max_acc"`
	MinForce                    [][]types.PointInTime[types.Second, types.Newton]       `json:"min_force"`
	MaxForce                    [][]types.PointInTime[types.Second, types.Newton]       `json:"max_force"`
	MinImpulse                  [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"min_impulse"`
	MaxImpulse                  [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"max_impulse"`
	AvgWork                     [][]types.Joule                                         `json:"avg_work"`
	MinWork                     [][]types.PointInTime[types.Second, types.Joule]        `json:"min_work"`
	MaxWork                     [][]types.PointInTime[types.Second, types.Joule]        `json:"max_work"`
	AvgPower                    [][]types.Watt                                          `json:"avg_power"`
	MinPower                    [][]types.PointInTime[types.Second, types.Watt]         `json:"min_power"`
	MaxPower                    [][]types.PointInTime[types.Second, types.Watt]         `json:"max_power"`
	BarPathCalcParamsVersion    int32                                                   `json:"bar_path_calc_params_version"`
	BarPathTrackerParamsVersion int32                                                   `json:"bar_path_tracker_params_version"`
}

func (q *Queries) CreatePhysicsData(ctx context.Context, arg CreatePhysicsDataParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPhysicsData,
		arg.Path,
		arg.Time,
		arg.Position,
		arg.Velocity,
		arg.Acceleration,
		arg.Jerk,
		arg.Force,
		arg.Impulse,
		arg.Work,
		arg.Power,
		arg.RepSplits,
		arg.MinVel,
		arg.MaxVel,
		arg.MinAcc,
		arg.MaxAcc,
		arg.MinForce,
		arg.MaxForce,
		arg.MinImpulse,
		arg.MaxImpulse,
		arg.AvgWork,
		arg.MinWork,
		arg.MaxWork,
		arg.AvgPower,
		arg.MinPower,
		arg.MaxPower,
		arg.BarPathCalcParamsVersion,
		arg.BarPathTrackerParamsVersion,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteClientsByEmail = `-- name: DeleteClientsByEmail :one
WITH deleted_clients AS (
    DELETE FROM providentia.client
    WHERE email = ANY($1::TEXT[])
    RETURNING id
) SELECT COUNT(*) FROM deleted_clients
`

func (q *Queries) DeleteClientsByEmail(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, deleteClientsByEmail, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteExercisesByName = `-- name: DeleteExercisesByName :one
WITH deleted_exercises AS (
	DELETE FROM providentia.exercise
	WHERE name = ANY($1::TEXT[])
	RETURNING id
) SELECT COUNT(*) FROM deleted_exercises
`

func (q *Queries) DeleteExercisesByName(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, deleteExercisesByName, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteHyperparamsByVersionFor = `-- name: DeleteHyperparamsByVersionFor :one
WITH deleted_hyperparams AS (
	DELETE FROM providentia.hyperparams
	WHERE model_id=$1 AND version = ANY($2::INT4[])
	RETURNING id
) SELECT COUNT(*) FROM deleted_hyperparams
`

type DeleteHyperparamsByVersionForParams struct {
	ModelID  types.ModelID `json:"model_id"`
	Versions []int32       `json:"versions"`
}

func (q *Queries) DeleteHyperparamsByVersionFor(ctx context.Context, arg DeleteHyperparamsByVersionForParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteHyperparamsByVersionFor, arg.ModelID, arg.Versions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteWorkout = `-- name: DeleteWorkout :one
WITH deleted_exercises AS (
	DELETE FROM providentia.training_log
	USING providentia.client
	WHERE
		providentia.client.id = providentia.training_log.client_id AND
		providentia.client.email = $1 AND
		providentia.training_log.inter_session_cntr = $2 AND
		providentia.training_log.date_performed = $3
	RETURNING providentia.training_log.id
) SELECT COUNT(*) FROM deleted_exercises
`

type DeleteWorkoutParams struct {
	Email            string      `json:"email"`
	InterSessionCntr int16       `json:"inter_session_cntr"`
	DatePerformed    pgtype.Date `json:"date_performed"`
}

func (q *Queries) DeleteWorkout(ctx context.Context, arg DeleteWorkoutParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteWorkout, arg.Email, arg.InterSessionCntr, arg.DatePerformed)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteWorkoutsBetweenDates = `-- name: DeleteWorkoutsBetweenDates :one
WITH deleted_exercises AS (
	DELETE FROM providentia.training_log
	USING providentia.client
	WHERE
		providentia.client.id = providentia.training_log.client_id AND
		providentia.client.email = $1 AND
		providentia.training_log.date_performed BETWEEN $2::DATE AND $3::DATE
	RETURNING providentia.training_log.id
) SELECT COUNT(*) FROM deleted_exercises
`

type DeleteWorkoutsBetweenDatesParams struct {
	Email  string      `json:"email"`
	Start  pgtype.Date `json:"start"`
	Ending pgtype.Date `json:"ending"`
}

func (q *Queries) DeleteWorkoutsBetweenDates(ctx context.Context, arg DeleteWorkoutsBetweenDatesParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteWorkoutsBetweenDates, arg.Email, arg.Start, arg.Ending)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const ensureClientsExist = `-- name: EnsureClientsExist :exec
INSERT INTO providentia.client (first_name, last_name, email)
SELECT
	UNNEST($1::TEXT[]),
	UNNEST($2::TEXT[]),
	UNNEST($3::TEXT[])
ON CONFLICT (first_name, last_name, email) DO NOTHING
`

type EnsureClientsExistParams struct {
	FirstNames []string `json:"first_names"`
	LastNames  []string `json:"last_names"`
	Emails     []string `json:"emails"`
}

func (q *Queries) EnsureClientsExist(ctx context.Context, arg EnsureClientsExistParams) error {
	_, err := q.db.Exec(ctx, ensureClientsExist, arg.FirstNames, arg.LastNames, arg.Emails)
	return err
}

const ensureExercisesExist = `-- name: EnsureExercisesExist :exec
INSERT INTO providentia.exercise (name, kind_id, focus_id)
SELECT
	UNNEST($1::TEXT[]),
	UNNEST($2::INT4[]),
	UNNEST($3::INT4[])
ON CONFLICT (name, kind_id, focus_id) DO NOTHING
`

type EnsureExercisesExistParams struct {
	Names   []string `json:"names"`
	Kinds   []int32  `json:"kinds"`
	Focuses []int32  `json:"focuses"`
}

func (q *Queries) EnsureExercisesExist(ctx context.Context, arg EnsureExercisesExistParams) error {
	_, err := q.db.Exec(ctx, ensureExercisesExist, arg.Names, arg.Kinds, arg.Focuses)
	return err
}

const findClientsByEmail = `-- name: FindClientsByEmail :many
SELECT
	providentia.client.first_name,
	providentia.client.last_name,
	providentia.client.email,
	ord::INT8
FROM providentia.client 
JOIN UNNEST($1::TEXT[])
WITH ORDINALITY t(email, ord)
USING (email) 
ORDER BY ord
`

type FindClientsByEmailRow struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
	Ord       int64  `json:"ord"`
}

func (q *Queries) FindClientsByEmail(ctx context.Context, dollar_1 []string) ([]FindClientsByEmailRow, error) {
	rows, err := q.db.Query(ctx, findClientsByEmail, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindClientsByEmailRow
	for rows.Next() {
		var i FindClientsByEmailRow
		if err := rows.Scan(
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Ord,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWorkoutData = `-- name: GetAllWorkoutData :many
SELECT
	providentia.exercise.name,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.volume,
	providentia.training_log.exertion,
	providentia.training_log.total_reps,
	providentia.physics_data.time,
	providentia.physics_data.position,
	providentia.physics_data.velocity,
	providentia.physics_data.acceleration,
	providentia.physics_data.jerk,
	providentia.physics_data.force,
	providentia.physics_data.impulse,
	providentia.physics_data.work,
	providentia.physics_data.power,
	providentia.physics_data.rep_splits,
	providentia.physics_data.min_vel,
	providentia.physics_data.max_vel,
	providentia.physics_data.min_acc,
	providentia.physics_data.max_acc,
	providentia.physics_data.min_force,
	providentia.physics_data.max_force,
	providentia.physics_data.min_impulse,
	providentia.physics_data.max_impulse,
	providentia.physics_data.avg_work,
	providentia.physics_data.min_work,
	providentia.physics_data.max_work,
	providentia.physics_data.avg_power,
	providentia.physics_data.min_power,
	providentia.physics_data.max_power
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
LEFT JOIN providentia.physics_data
	ON providentia.training_log.physics_id=providentia.physics_data.id
WHERE
	providentia.client.email = $1 AND
	providentia.training_log.inter_session_cntr = $2 AND
	providentia.training_log.date_performed = $3
ORDER BY training_log.inter_workout_cntr ASC
`

type GetAllWorkoutDataParams struct {
	Email            string      `json:"email"`
	InterSessionCntr int16       `json:"inter_session_cntr"`
	DatePerformed    pgtype.Date `json:"date_performed"`
}

type GetAllWorkoutDataRow struct {
	Name         string                                                  `json:"name"`
	Weight       types.Kilogram                                          `json:"weight"`
	Sets         float64                                                 `json:"sets"`
	Reps         int32                                                   `json:"reps"`
	Effort       types.RPE                                               `json:"effort"`
	Volume       types.Kilogram                                          `json:"volume"`
	Exertion     types.RPE                                               `json:"exertion"`
	TotalReps    float64                                                 `json:"total_reps"`
	Time         [][]types.Second                                        `json:"time"`
	Position     [][]types.Vec2[types.Meter, types.Meter]                `json:"position"`
	Velocity     [][]types.Vec2[types.MeterPerSec, types.MeterPerSec]    `json:"velocity"`
	Acceleration [][]types.Vec2[types.MeterPerSec2, types.MeterPerSec2]  `json:"acceleration"`
	Jerk         [][]types.Vec2[types.MeterPerSec3, types.MeterPerSec3]  `json:"jerk"`
	Force        [][]types.Vec2[types.Newton, types.Newton]              `json:"force"`
	Impulse      [][]types.Vec2[types.NewtonSec, types.NewtonSec]        `json:"impulse"`
	Work         [][]types.Joule                                         `json:"work"`
	Power        [][]types.Watt                                          `json:"power"`
	RepSplits    [][]types.Split                                         `json:"rep_splits"`
	MinVel       [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"min_vel"`
	MaxVel       [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"max_vel"`
	MinAcc       [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"min_acc"`
	MaxAcc       [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"max_acc"`
	MinForce     [][]types.PointInTime[types.Second, types.Newton]       `json:"min_force"`
	MaxForce     [][]types.PointInTime[types.Second, types.Newton]       `json:"max_force"`
	MinImpulse   [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"min_impulse"`
	MaxImpulse   [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"max_impulse"`
	AvgWork      [][]types.Joule                                         `json:"avg_work"`
	MinWork      [][]types.PointInTime[types.Second, types.Joule]        `json:"min_work"`
	MaxWork      [][]types.PointInTime[types.Second, types.Joule]        `json:"max_work"`
	AvgPower     [][]types.Watt                                          `json:"avg_power"`
	MinPower     [][]types.PointInTime[types.Second, types.Watt]         `json:"min_power"`
	MaxPower     [][]types.PointInTime[types.Second, types.Watt]         `json:"max_power"`
}

// TODO - figure out if ordinality trick can be used here - is there a way to
// make the join on multiple columns?
func (q *Queries) GetAllWorkoutData(ctx context.Context, arg GetAllWorkoutDataParams) ([]GetAllWorkoutDataRow, error) {
	rows, err := q.db.Query(ctx, getAllWorkoutData, arg.Email, arg.InterSessionCntr, arg.DatePerformed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllWorkoutDataRow
	for rows.Next() {
		var i GetAllWorkoutDataRow
		if err := rows.Scan(
			&i.Name,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Volume,
			&i.Exertion,
			&i.TotalReps,
			&i.Time,
			&i.Position,
			&i.Velocity,
			&i.Acceleration,
			&i.Jerk,
			&i.Force,
			&i.Impulse,
			&i.Work,
			&i.Power,
			&i.RepSplits,
			&i.MinVel,
			&i.MaxVel,
			&i.MinAcc,
			&i.MaxAcc,
			&i.MinForce,
			&i.MaxForce,
			&i.MinImpulse,
			&i.MaxImpulse,
			&i.AvgWork,
			&i.MinWork,
			&i.MaxWork,
			&i.AvgPower,
			&i.MinPower,
			&i.MaxPower,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWorkoutDataBetweenDates = `-- name: GetAllWorkoutDataBetweenDates :many
SELECT
	providentia.exercise.name,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.volume,
	providentia.training_log.exertion,
	providentia.training_log.total_reps,
	providentia.training_log.date_performed,
	providentia.training_log.inter_session_cntr,
	providentia.physics_data.time,
	providentia.physics_data.position,
	providentia.physics_data.velocity,
	providentia.physics_data.acceleration,
	providentia.physics_data.jerk,
	providentia.physics_data.force,
	providentia.physics_data.impulse,
	providentia.physics_data.work,
	providentia.physics_data.power,
	providentia.physics_data.rep_splits,
	providentia.physics_data.min_vel,
	providentia.physics_data.max_vel,
	providentia.physics_data.min_acc,
	providentia.physics_data.max_acc,
	providentia.physics_data.min_force,
	providentia.physics_data.max_force,
	providentia.physics_data.min_impulse,
	providentia.physics_data.max_impulse,
	providentia.physics_data.avg_work,
	providentia.physics_data.min_work,
	providentia.physics_data.max_work,
	providentia.physics_data.avg_power,
	providentia.physics_data.min_power,
	providentia.physics_data.max_power
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
LEFT JOIN providentia.physics_data
	ON providentia.training_log.physics_id=providentia.physics_data.id
WHERE
	providentia.client.email = $1 AND
	providentia.training_log.date_performed BETWEEN $2::DATE AND $3::DATE
ORDER BY 
	training_log.date_performed ASC,
	training_log.inter_session_cntr ASC,
	training_log.inter_workout_cntr ASC
`

type GetAllWorkoutDataBetweenDatesParams struct {
	Email  string      `json:"email"`
	Start  pgtype.Date `json:"start"`
	Ending pgtype.Date `json:"ending"`
}

type GetAllWorkoutDataBetweenDatesRow struct {
	Name             string                                                  `json:"name"`
	Weight           types.Kilogram                                          `json:"weight"`
	Sets             float64                                                 `json:"sets"`
	Reps             int32                                                   `json:"reps"`
	Effort           types.RPE                                               `json:"effort"`
	Volume           types.Kilogram                                          `json:"volume"`
	Exertion         types.RPE                                               `json:"exertion"`
	TotalReps        float64                                                 `json:"total_reps"`
	DatePerformed    pgtype.Date                                             `json:"date_performed"`
	InterSessionCntr int16                                                   `json:"inter_session_cntr"`
	Time             [][]types.Second                                        `json:"time"`
	Position         [][]types.Vec2[types.Meter, types.Meter]                `json:"position"`
	Velocity         [][]types.Vec2[types.MeterPerSec, types.MeterPerSec]    `json:"velocity"`
	Acceleration     [][]types.Vec2[types.MeterPerSec2, types.MeterPerSec2]  `json:"acceleration"`
	Jerk             [][]types.Vec2[types.MeterPerSec3, types.MeterPerSec3]  `json:"jerk"`
	Force            [][]types.Vec2[types.Newton, types.Newton]              `json:"force"`
	Impulse          [][]types.Vec2[types.NewtonSec, types.NewtonSec]        `json:"impulse"`
	Work             [][]types.Joule                                         `json:"work"`
	Power            [][]types.Watt                                          `json:"power"`
	RepSplits        [][]types.Split                                         `json:"rep_splits"`
	MinVel           [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"min_vel"`
	MaxVel           [][]types.PointInTime[types.Second, types.MeterPerSec]  `json:"max_vel"`
	MinAcc           [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"min_acc"`
	MaxAcc           [][]types.PointInTime[types.Second, types.MeterPerSec2] `json:"max_acc"`
	MinForce         [][]types.PointInTime[types.Second, types.Newton]       `json:"min_force"`
	MaxForce         [][]types.PointInTime[types.Second, types.Newton]       `json:"max_force"`
	MinImpulse       [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"min_impulse"`
	MaxImpulse       [][]types.PointInTime[types.Second, types.NewtonSec]    `json:"max_impulse"`
	AvgWork          [][]types.Joule                                         `json:"avg_work"`
	MinWork          [][]types.PointInTime[types.Second, types.Joule]        `json:"min_work"`
	MaxWork          [][]types.PointInTime[types.Second, types.Joule]        `json:"max_work"`
	AvgPower         [][]types.Watt                                          `json:"avg_power"`
	MinPower         [][]types.PointInTime[types.Second, types.Watt]         `json:"min_power"`
	MaxPower         [][]types.PointInTime[types.Second, types.Watt]         `json:"max_power"`
}

func (q *Queries) GetAllWorkoutDataBetweenDates(ctx context.Context, arg GetAllWorkoutDataBetweenDatesParams) ([]GetAllWorkoutDataBetweenDatesRow, error) {
	rows, err := q.db.Query(ctx, getAllWorkoutDataBetweenDates, arg.Email, arg.Start, arg.Ending)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllWorkoutDataBetweenDatesRow
	for rows.Next() {
		var i GetAllWorkoutDataBetweenDatesRow
		if err := rows.Scan(
			&i.Name,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Volume,
			&i.Exertion,
			&i.TotalReps,
			&i.DatePerformed,
			&i.InterSessionCntr,
			&i.Time,
			&i.Position,
			&i.Velocity,
			&i.Acceleration,
			&i.Jerk,
			&i.Force,
			&i.Impulse,
			&i.Work,
			&i.Power,
			&i.RepSplits,
			&i.MinVel,
			&i.MaxVel,
			&i.MinAcc,
			&i.MaxAcc,
			&i.MinForce,
			&i.MaxForce,
			&i.MinImpulse,
			&i.MaxImpulse,
			&i.AvgWork,
			&i.MinWork,
			&i.MaxWork,
			&i.AvgPower,
			&i.MinPower,
			&i.MaxPower,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientIdByEmail = `-- name: GetClientIdByEmail :one
SELECT id FROM providentia.client WHERE email = $1
`

func (q *Queries) GetClientIdByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getClientIdByEmail, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getClientsByEmail = `-- name: GetClientsByEmail :many
SELECT
	providentia.client.first_name,
	providentia.client.last_name,
	providentia.client.email
FROM providentia.client 
JOIN UNNEST($1::TEXT[])
WITH ORDINALITY t(email, ord)
USING (email) 
ORDER BY ord
`

type GetClientsByEmailRow struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) GetClientsByEmail(ctx context.Context, dollar_1 []string) ([]GetClientsByEmailRow, error) {
	rows, err := q.db.Query(ctx, getClientsByEmail, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientsByEmailRow
	for rows.Next() {
		var i GetClientsByEmailRow
		if err := rows.Scan(&i.FirstName, &i.LastName, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseIdByName = `-- name: GetExerciseIdByName :one
SELECT id FROM providentia.exercise WHERE name = $1
`

func (q *Queries) GetExerciseIdByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getExerciseIdByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getExercisesByName = `-- name: GetExercisesByName :many
SELECT
	providentia.exercise.name,
	providentia.exercise.kind_id,
	providentia.exercise.focus_id
FROM providentia.exercise 
JOIN UNNEST($1::TEXT[])
WITH ORDINALITY t(name, ord)
USING (name) 
ORDER BY ord
`

type GetExercisesByNameRow struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

func (q *Queries) GetExercisesByName(ctx context.Context, dollar_1 []string) ([]GetExercisesByNameRow, error) {
	rows, err := q.db.Query(ctx, getExercisesByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExercisesByNameRow
	for rows.Next() {
		var i GetExercisesByNameRow
		if err := rows.Scan(&i.Name, &i.KindID, &i.FocusID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHyperparamsByVersionFor = `-- name: GetHyperparamsByVersionFor :many
SELECT
	providentia.hyperparams.version,
	providentia.hyperparams.params
FROM providentia.hyperparams
JOIN UNNEST($2::INT4[])
WITH ORDINALITY t(version, ord)
USING (version)
WHERE model_id=$1
ORDER BY ord
`

type GetHyperparamsByVersionForParams struct {
	ModelID  types.ModelID `json:"model_id"`
	Versions []int32       `json:"versions"`
}

type GetHyperparamsByVersionForRow struct {
	Version int32  `json:"version"`
	Params  []byte `json:"params"`
}

func (q *Queries) GetHyperparamsByVersionFor(ctx context.Context, arg GetHyperparamsByVersionForParams) ([]GetHyperparamsByVersionForRow, error) {
	rows, err := q.db.Query(ctx, getHyperparamsByVersionFor, arg.ModelID, arg.Versions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHyperparamsByVersionForRow
	for rows.Next() {
		var i GetHyperparamsByVersionForRow
		if err := rows.Scan(&i.Version, &i.Params); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumClients = `-- name: GetNumClients :one
SELECT COUNT(*) FROM providentia.client
`

func (q *Queries) GetNumClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumClients)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumExercises = `-- name: GetNumExercises :one
SELECT COUNT(*) FROM providentia.exercise
`

func (q *Queries) GetNumExercises(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumExercises)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumHyperparams = `-- name: GetNumHyperparams :one
SELECT COUNT(*) FROM providentia.hyperparams
`

func (q *Queries) GetNumHyperparams(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumHyperparams)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumHyperparamsFor = `-- name: GetNumHyperparamsFor :one
SELECT COUNT(*) FROM providentia.hyperparams
WHERE providentia.hyperparams.model_id=$1
`

func (q *Queries) GetNumHyperparamsFor(ctx context.Context, modelID types.ModelID) (int64, error) {
	row := q.db.QueryRow(ctx, getNumHyperparamsFor, modelID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumWorkoutsForClient = `-- name: GetNumWorkoutsForClient :one
SELECT COUNT(*) FROM (
	SELECT date_performed, inter_session_cntr
	FROM providentia.training_log
	JOIN providentia.client
		ON providentia.training_log.client_id = providentia.client.id
	WHERE providentia.client.email = $1
	GROUP BY date_performed, inter_session_cntr
) AS result
`

func (q *Queries) GetNumWorkoutsForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getNumWorkoutsForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalNumPhysicsEntriesForClient = `-- name: GetTotalNumPhysicsEntriesForClient :one
SELECT COUNT(*) FROM providentia.physics_data
JOIN providentia.training_log
	ON providentia.physics_data.id = providentia.training_log.physics_id
JOIN providentia.client
	ON providentia.training_log.client_id = providentia.client.id
WHERE
	providentia.client.email = $1
`

func (q *Queries) GetTotalNumPhysicsEntriesForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNumPhysicsEntriesForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalNumTrainingLogEntriesForClient = `-- name: GetTotalNumTrainingLogEntriesForClient :one
SELECT COUNT(*) FROM providentia.training_log
JOIN providentia.client
	ON providentia.training_log.client_id = providentia.client.id
WHERE providentia.client.email = $1
`

func (q *Queries) GetTotalNumTrainingLogEntriesForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNumTrainingLogEntriesForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateClientByEmail = `-- name: UpdateClientByEmail :exec
UPDATE providentia.client SET first_name=$1, last_name=$2
WHERE providentia.client.email=$3
`

type UpdateClientByEmailParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) UpdateClientByEmail(ctx context.Context, arg UpdateClientByEmailParams) error {
	_, err := q.db.Exec(ctx, updateClientByEmail, arg.FirstName, arg.LastName, arg.Email)
	return err
}

const updateExerciseByName = `-- name: UpdateExerciseByName :exec
UPDATE providentia.exercise SET kind_id=$2, focus_id=$3
WHERE providentia.exercise.name=$1
`

type UpdateExerciseByNameParams struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

func (q *Queries) UpdateExerciseByName(ctx context.Context, arg UpdateExerciseByNameParams) error {
	_, err := q.db.Exec(ctx, updateExerciseByName, arg.Name, arg.KindID, arg.FocusID)
	return err
}

const updateExerciseFocusSerialCount = `-- name: UpdateExerciseFocusSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise_focus', 'id'),
	(SELECT MAX(id) FROM providentia.exercise_focus) + 1
)
`

func (q *Queries) UpdateExerciseFocusSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseFocusSerialCount)
	return err
}

const updateExerciseKindSerialCount = `-- name: UpdateExerciseKindSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise_kind', 'id'),
	(SELECT MAX(id) FROM providentia.exercise_kind) + 1
)
`

func (q *Queries) UpdateExerciseKindSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseKindSerialCount)
	return err
}

const updateExerciseSerialCount = `-- name: UpdateExerciseSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise', 'id'),
	(SELECT MAX(id) FROM providentia.exercise) + 1
)
`

func (q *Queries) UpdateExerciseSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseSerialCount)
	return err
}

const updateHyperparamsSerialCount = `-- name: UpdateHyperparamsSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.hyperparams', 'id'),
	(SELECT MAX(id) FROM providentia.hyperparams) + 1
)
`

func (q *Queries) UpdateHyperparamsSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateHyperparamsSerialCount)
	return err
}

const updateModelSerialCount = `-- name: UpdateModelSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.model', 'id'),
	(SELECT MAX(id) FROM providentia.model) + 1
)
`

func (q *Queries) UpdateModelSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateModelSerialCount)
	return err
}
