// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package dal

import (
	"context"

	"code.barbellmath.net/barbell-math/providentia/lib/types"
	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateClientsParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

type BulkCreateExerciseFocusWithIDParams struct {
	ID    int32  `json:"id"`
	Focus string `json:"focus"`
}

type BulkCreateExerciseKindWithIDParams struct {
	ID          int32  `json:"id"`
	Kind        string `json:"kind"`
	Description string `json:"description"`
}

type BulkCreateExerciseWithIDParams struct {
	ID      int32               `json:"id"`
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

type BulkCreateExercisesParams struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

type BulkCreateModelStatesParams struct {
	ClientID      int64   `json:"client_id"`
	TrainingLogID int64   `json:"training_log_id"`
	ModelID       int32   `json:"model_id"`
	V1            float64 `json:"v1"`
	V2            float64 `json:"v2"`
	V3            float64 `json:"v3"`
	V4            float64 `json:"v4"`
	V5            float64 `json:"v5"`
	V6            float64 `json:"v6"`
	V7            float64 `json:"v7"`
	V8            float64 `json:"v8"`
	V9            float64 `json:"v9"`
	V10           float64 `json:"v10"`
	TimeFrame     int32   `json:"time_frame"`
	Mse           float64 `json:"mse"`
	PredWeight    float64 `json:"pred_weight"`
}

type BulkCreateModelsWithIDParams struct {
	ID          int32  `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type BulkCreateTrainingLogParams struct {
	ExerciseID       int32       `json:"exercise_id"`
	ClientID         int64       `json:"client_id"`
	PhysicsID        pgtype.Int8 `json:"physics_id"`
	DatePerformed    pgtype.Date `json:"date_performed"`
	Weight           float64     `json:"weight"`
	Sets             float64     `json:"sets"`
	Reps             int32       `json:"reps"`
	Effort           float64     `json:"effort"`
	InterSessionCntr int32       `json:"inter_session_cntr"`
	InterWorkoutCntr int32       `json:"inter_workout_cntr"`
}

const clientLastWorkoutDate = `-- name: ClientLastWorkoutDate :one
SELECT date_performed FROM providentia.training_log
WHERE client_id=$1
ORDER BY date_performed DESC LIMIT 1
`

func (q *Queries) ClientLastWorkoutDate(ctx context.Context, clientID int64) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, clientLastWorkoutDate, clientID)
	var date_performed pgtype.Date
	err := row.Scan(&date_performed)
	return date_performed, err
}

const clientTrainingLogDataDateRangeAscending = `-- name: ClientTrainingLogDataDateRangeAscending :many
SELECT
	providentia.training_log.id,
	providentia.training_log.exercise_id,
	($2::date-providentia.training_log.date_performed) AS days_since,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.inter_session_cntr,
	providentia.training_log.inter_workout_cntr
FROM providentia.training_log
WHERE providentia.training_log.client_id=$1
	AND providentia.training_log.date_performed<$2
ORDER BY
	-- These cannot be labeled with providentia.training_log because you will
	-- get a ` + "`" + `column reference "" not found` + "`" + ` error.
	date_performed ASC, id ASC
`

type ClientTrainingLogDataDateRangeAscendingParams struct {
	ClientID      int64       `json:"client_id"`
	DatePerformed pgtype.Date `json:"date_performed"`
}

type ClientTrainingLogDataDateRangeAscendingRow struct {
	ID               int64   `json:"id"`
	ExerciseID       int32   `json:"exercise_id"`
	DaysSince        int32   `json:"days_since"`
	Weight           float64 `json:"weight"`
	Sets             float64 `json:"sets"`
	Reps             int32   `json:"reps"`
	Effort           float64 `json:"effort"`
	InterSessionCntr int32   `json:"inter_session_cntr"`
	InterWorkoutCntr int32   `json:"inter_workout_cntr"`
}

func (q *Queries) ClientTrainingLogDataDateRangeAscending(ctx context.Context, arg ClientTrainingLogDataDateRangeAscendingParams) ([]ClientTrainingLogDataDateRangeAscendingRow, error) {
	rows, err := q.db.Query(ctx, clientTrainingLogDataDateRangeAscending, arg.ClientID, arg.DatePerformed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientTrainingLogDataDateRangeAscendingRow
	for rows.Next() {
		var i ClientTrainingLogDataDateRangeAscendingRow
		if err := rows.Scan(
			&i.ID,
			&i.ExerciseID,
			&i.DaysSince,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.InterSessionCntr,
			&i.InterWorkoutCntr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteClientsByEmail = `-- name: DeleteClientsByEmail :one
WITH deleted_clients AS (
    DELETE FROM providentia.client
    WHERE email = ANY($1::text[])
    RETURNING id
) SELECT COUNT(*) FROM deleted_clients
`

func (q *Queries) DeleteClientsByEmail(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, deleteClientsByEmail, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteExercisesByName = `-- name: DeleteExercisesByName :one
WITH deleted_exercises AS (
    DELETE FROM providentia.exercise
    WHERE name = ANY($1::text[])
    RETURNING id
) SELECT COUNT(*) FROM deleted_exercises
`

func (q *Queries) DeleteExercisesByName(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, deleteExercisesByName, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllClientsTrainingLogData = `-- name: GetAllClientsTrainingLogData :many
SELECT
	providentia.client.email,
	providentia.exercise.name,
	providentia.training_log.date_performed,
	providentia.training_log.inter_session_cntr,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.volume,
	providentia.training_log.exertion,
	providentia.training_log.total_reps
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
ORDER BY
	-- These cannot be labeled with providentia.training_log because you will
	-- get a ` + "`" + `column reference "" not found` + "`" + ` error.
	client.id DESC,
	training_log.date_performed DESC,
	training_log.id DESC
LIMIT $1
`

type GetAllClientsTrainingLogDataRow struct {
	Email            string      `json:"email"`
	Name             string      `json:"name"`
	DatePerformed    pgtype.Date `json:"date_performed"`
	InterSessionCntr int32       `json:"inter_session_cntr"`
	Weight           float64     `json:"weight"`
	Sets             float64     `json:"sets"`
	Reps             int32       `json:"reps"`
	Effort           float64     `json:"effort"`
	Volume           float64     `json:"volume"`
	Exertion         float64     `json:"exertion"`
	TotalReps        float64     `json:"total_reps"`
}

func (q *Queries) GetAllClientsTrainingLogData(ctx context.Context, limit int32) ([]GetAllClientsTrainingLogDataRow, error) {
	rows, err := q.db.Query(ctx, getAllClientsTrainingLogData, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllClientsTrainingLogDataRow
	for rows.Next() {
		var i GetAllClientsTrainingLogDataRow
		if err := rows.Scan(
			&i.Email,
			&i.Name,
			&i.DatePerformed,
			&i.InterSessionCntr,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Volume,
			&i.Exertion,
			&i.TotalReps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientIDFromEmail = `-- name: GetClientIDFromEmail :one
SELECT ID FROM providentia.client WHERE email=$1
`

func (q *Queries) GetClientIDFromEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getClientIDFromEmail, email)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getClientTrainingLogData = `-- name: GetClientTrainingLogData :many
SELECT
	providentia.exercise.name,
	providentia.training_log.date_performed,
	providentia.training_log.inter_session_cntr,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
WHERE providentia.client.email=$1
ORDER BY
	-- These cannot be labeled with providentia.training_log because you will
	-- get a ` + "`" + `column reference "" not found` + "`" + ` error.
	training_log.date_performed DESC, training_log.id DESC
LIMIT $2
`

type GetClientTrainingLogDataParams struct {
	Email string `json:"email"`
	Limit int32  `json:"limit"`
}

type GetClientTrainingLogDataRow struct {
	Name             string      `json:"name"`
	DatePerformed    pgtype.Date `json:"date_performed"`
	InterSessionCntr int32       `json:"inter_session_cntr"`
	Weight           float64     `json:"weight"`
	Sets             float64     `json:"sets"`
	Reps             int32       `json:"reps"`
	Effort           float64     `json:"effort"`
}

func (q *Queries) GetClientTrainingLogData(ctx context.Context, arg GetClientTrainingLogDataParams) ([]GetClientTrainingLogDataRow, error) {
	rows, err := q.db.Query(ctx, getClientTrainingLogData, arg.Email, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientTrainingLogDataRow
	for rows.Next() {
		var i GetClientTrainingLogDataRow
		if err := rows.Scan(
			&i.Name,
			&i.DatePerformed,
			&i.InterSessionCntr,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientsByEmail = `-- name: GetClientsByEmail :many
SELECT first_name, last_name, email
FROM providentia.client WHERE email = ANY($1::text[])
`

type GetClientsByEmailRow struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) GetClientsByEmail(ctx context.Context, dollar_1 []string) ([]GetClientsByEmailRow, error) {
	rows, err := q.db.Query(ctx, getClientsByEmail, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientsByEmailRow
	for rows.Next() {
		var i GetClientsByEmailRow
		if err := rows.Scan(&i.FirstName, &i.LastName, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseIDs = `-- name: GetExerciseIDs :one
SELECT
	providentia.exercise.id AS exercise_id,
	providentia.exercise_kind.id AS kind_id,
	providentia.exercise_focus.id AS focus_id
FROM providentia.exercise
JOIN providentia.exercise_kind
	ON providentia.exercise.kind_id=providentia.exercise_kind.id
JOIN providentia.exercise_focus
	ON providentia.exercise.focus_id=providentia.exercise_focus.id
WHERE name=$1
`

type GetExerciseIDsRow struct {
	ExerciseID int32 `json:"exercise_id"`
	KindID     int32 `json:"kind_id"`
	FocusID    int32 `json:"focus_id"`
}

func (q *Queries) GetExerciseIDs(ctx context.Context, name string) (GetExerciseIDsRow, error) {
	row := q.db.QueryRow(ctx, getExerciseIDs, name)
	var i GetExerciseIDsRow
	err := row.Scan(&i.ExerciseID, &i.KindID, &i.FocusID)
	return i, err
}

const getExerciseId = `-- name: GetExerciseId :one
SELECT id FROM providentia.exercise WHERE name=$1
`

func (q *Queries) GetExerciseId(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getExerciseId, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getExercisesByName = `-- name: GetExercisesByName :many
SELECT name, kind_id, focus_id
FROM providentia.exercise WHERE name = ANY($1::text[])
`

type GetExercisesByNameRow struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

func (q *Queries) GetExercisesByName(ctx context.Context, dollar_1 []string) ([]GetExercisesByNameRow, error) {
	rows, err := q.db.Query(ctx, getExercisesByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExercisesByNameRow
	for rows.Next() {
		var i GetExercisesByNameRow
		if err := rows.Scan(&i.Name, &i.KindID, &i.FocusID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumClients = `-- name: GetNumClients :one
SELECT COUNT(*) FROM providentia.client
`

func (q *Queries) GetNumClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumClients)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumExercises = `-- name: GetNumExercises :one
SELECT COUNT(*) FROM providentia.exercise
`

func (q *Queries) GetNumExercises(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumExercises)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateClientByEmail = `-- name: UpdateClientByEmail :exec
UPDATE providentia.client SET first_name=$1, last_name=$2
WHERE providentia.client.email=$3
`

type UpdateClientByEmailParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) UpdateClientByEmail(ctx context.Context, arg UpdateClientByEmailParams) error {
	_, err := q.db.Exec(ctx, updateClientByEmail, arg.FirstName, arg.LastName, arg.Email)
	return err
}

const updateExerciseByName = `-- name: UpdateExerciseByName :exec
UPDATE providentia.exercise SET kind_id=$2, focus_id=$3
WHERE providentia.exercise.name=$1
`

type UpdateExerciseByNameParams struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

func (q *Queries) UpdateExerciseByName(ctx context.Context, arg UpdateExerciseByNameParams) error {
	_, err := q.db.Exec(ctx, updateExerciseByName, arg.Name, arg.KindID, arg.FocusID)
	return err
}

const updateExerciseFocusSerialCount = `-- name: UpdateExerciseFocusSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise_focus', 'id'),
	(SELECT MAX(id) FROM providentia.exercise_focus) + 1
)
`

func (q *Queries) UpdateExerciseFocusSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseFocusSerialCount)
	return err
}

const updateExerciseKindSerialCount = `-- name: UpdateExerciseKindSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise_kind', 'id'),
	(SELECT MAX(id) FROM providentia.exercise_kind) + 1
)
`

func (q *Queries) UpdateExerciseKindSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseKindSerialCount)
	return err
}

const updateExerciseSerialCount = `-- name: UpdateExerciseSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise', 'id'),
	(SELECT MAX(id) FROM providentia.exercise) + 1
)
`

func (q *Queries) UpdateExerciseSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseSerialCount)
	return err
}

const updateModelSerialCount = `-- name: UpdateModelSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise', 'id'),
	(SELECT MAX(id) FROM providentia.exercise) + 1
)
`

func (q *Queries) UpdateModelSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateModelSerialCount)
	return err
}
