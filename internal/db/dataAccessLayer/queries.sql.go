// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package dal

import (
	"context"

	"code.barbellmath.net/barbell-math/providentia/lib/types"
	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateClientsParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

type BulkCreateExerciseFocusWithIDParams struct {
	ID    int32  `json:"id"`
	Focus string `json:"focus"`
}

type BulkCreateExerciseKindWithIDParams struct {
	ID          int32  `json:"id"`
	Kind        string `json:"kind"`
	Description string `json:"description"`
}

type BulkCreateExerciseWithIDParams struct {
	ID      int32               `json:"id"`
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

type BulkCreateExercisesParams struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

type BulkCreateModelStatesParams struct {
	ClientID      int64   `json:"client_id"`
	TrainingLogID int64   `json:"training_log_id"`
	ModelID       int32   `json:"model_id"`
	V1            float64 `json:"v1"`
	V2            float64 `json:"v2"`
	V3            float64 `json:"v3"`
	V4            float64 `json:"v4"`
	V5            float64 `json:"v5"`
	V6            float64 `json:"v6"`
	V7            float64 `json:"v7"`
	V8            float64 `json:"v8"`
	V9            float64 `json:"v9"`
	V10           float64 `json:"v10"`
	TimeFrame     int64   `json:"time_frame"`
	Mse           float64 `json:"mse"`
	PredWeight    float64 `json:"pred_weight"`
}

type BulkCreateModelsWithIDParams struct {
	ID          int32  `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type BulkCreateTrainingLogsParams struct {
	ExerciseID       int32          `json:"exercise_id"`
	ClientID         int64          `json:"client_id"`
	PhysicsID        pgtype.Int8    `json:"physics_id"`
	DatePerformed    pgtype.Date    `json:"date_performed"`
	Weight           types.Kilogram `json:"weight"`
	Sets             float64        `json:"sets"`
	Reps             int32          `json:"reps"`
	Effort           types.RPE      `json:"effort"`
	InterSessionCntr int16          `json:"inter_session_cntr"`
	InterWorkoutCntr int16          `json:"inter_workout_cntr"`
}

const clientExists = `-- name: ClientExists :one
SELECT EXISTS( SELECT 1 FROM providentia.client WHERE email = $1)
`

func (q *Queries) ClientExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, clientExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const clientLastWorkoutDate = `-- name: ClientLastWorkoutDate :one
SELECT date_performed FROM providentia.training_log
WHERE client_id=$1
ORDER BY date_performed DESC LIMIT 1
`

func (q *Queries) ClientLastWorkoutDate(ctx context.Context, clientID int64) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, clientLastWorkoutDate, clientID)
	var date_performed pgtype.Date
	err := row.Scan(&date_performed)
	return date_performed, err
}

const clientTrainingLogDataDateRangeAscending = `-- name: ClientTrainingLogDataDateRangeAscending :many
SELECT
	providentia.training_log.id,
	providentia.training_log.exercise_id,
	($2::date-providentia.training_log.date_performed) AS days_since,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.inter_session_cntr,
	providentia.training_log.inter_workout_cntr
FROM providentia.training_log
WHERE providentia.training_log.client_id=$1
	AND providentia.training_log.date_performed<$2
ORDER BY
	-- These cannot be labeled with providentia.training_log because you will
	-- get a ` + "`" + `column reference "" not found` + "`" + ` error.
	date_performed ASC, id ASC
`

type ClientTrainingLogDataDateRangeAscendingParams struct {
	ClientID      int64       `json:"client_id"`
	DatePerformed pgtype.Date `json:"date_performed"`
}

type ClientTrainingLogDataDateRangeAscendingRow struct {
	ID               int64          `json:"id"`
	ExerciseID       int32          `json:"exercise_id"`
	DaysSince        int32          `json:"days_since"`
	Weight           types.Kilogram `json:"weight"`
	Sets             float64        `json:"sets"`
	Reps             int32          `json:"reps"`
	Effort           types.RPE      `json:"effort"`
	InterSessionCntr int16          `json:"inter_session_cntr"`
	InterWorkoutCntr int16          `json:"inter_workout_cntr"`
}

func (q *Queries) ClientTrainingLogDataDateRangeAscending(ctx context.Context, arg ClientTrainingLogDataDateRangeAscendingParams) ([]ClientTrainingLogDataDateRangeAscendingRow, error) {
	rows, err := q.db.Query(ctx, clientTrainingLogDataDateRangeAscending, arg.ClientID, arg.DatePerformed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientTrainingLogDataDateRangeAscendingRow
	for rows.Next() {
		var i ClientTrainingLogDataDateRangeAscendingRow
		if err := rows.Scan(
			&i.ID,
			&i.ExerciseID,
			&i.DaysSince,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.InterSessionCntr,
			&i.InterWorkoutCntr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createPhysicsData = `-- name: CreatePhysicsData :one
INSERT INTO providentia.physics_data(
	path,
	time, position, velocity, acceleration, jerk,
	force, impulse, work, power,
	rep_splits
) VALUES (
	$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id
`

type CreatePhysicsDataParams struct {
	Path         []string                           `json:"path"`
	Time         [][]types.Second                   `json:"time"`
	Position     [][]types.Vec2[types.Meter]        `json:"position"`
	Velocity     [][]types.Vec2[types.MeterPerSec]  `json:"velocity"`
	Acceleration [][]types.Vec2[types.MeterPerSec2] `json:"acceleration"`
	Jerk         [][]types.Vec2[types.MeterPerSec3] `json:"jerk"`
	Force        [][]types.Vec2[types.Newton]       `json:"force"`
	Impulse      [][]types.Vec2[types.NewtonSec]    `json:"impulse"`
	Work         [][]types.Joule                    `json:"work"`
	Power        [][]types.Watt                     `json:"power"`
	RepSplits    [][]types.Split                    `json:"rep_splits"`
}

func (q *Queries) CreatePhysicsData(ctx context.Context, arg CreatePhysicsDataParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPhysicsData,
		arg.Path,
		arg.Time,
		arg.Position,
		arg.Velocity,
		arg.Acceleration,
		arg.Jerk,
		arg.Force,
		arg.Impulse,
		arg.Work,
		arg.Power,
		arg.RepSplits,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteClientsByEmail = `-- name: DeleteClientsByEmail :one
WITH deleted_clients AS (
    DELETE FROM providentia.client
    WHERE email = ANY($1::text[])
    RETURNING id
) SELECT COUNT(*) FROM deleted_clients
`

func (q *Queries) DeleteClientsByEmail(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, deleteClientsByEmail, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteExercisesByName = `-- name: DeleteExercisesByName :one
WITH deleted_exercises AS (
	DELETE FROM providentia.exercise
	WHERE name = ANY($1::text[])
	RETURNING id
) SELECT COUNT(*) FROM deleted_exercises
`

func (q *Queries) DeleteExercisesByName(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, deleteExercisesByName, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteWorkout = `-- name: DeleteWorkout :one
WITH deleted_exercises AS (
	DELETE FROM providentia.training_log
	USING providentia.client
	WHERE
		providentia.client.id = providentia.training_log.client_id AND
		providentia.client.email = $1 AND
		providentia.training_log.inter_session_cntr = $2 AND
		providentia.training_log.date_performed = $3
	RETURNING providentia.training_log.id
) SELECT COUNT(*) FROM deleted_exercises
`

type DeleteWorkoutParams struct {
	Email            string      `json:"email"`
	InterSessionCntr int16       `json:"inter_session_cntr"`
	DatePerformed    pgtype.Date `json:"date_performed"`
}

func (q *Queries) DeleteWorkout(ctx context.Context, arg DeleteWorkoutParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteWorkout, arg.Email, arg.InterSessionCntr, arg.DatePerformed)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteWorkoutsBetweenDates = `-- name: DeleteWorkoutsBetweenDates :one
WITH deleted_exercises AS (
	DELETE FROM providentia.training_log
	USING providentia.client
	WHERE
		providentia.client.id = providentia.training_log.client_id AND
		providentia.client.email = $1 AND
		providentia.training_log.date_performed BETWEEN $2::DATE AND $3::DATE
	RETURNING providentia.training_log.id
) SELECT COUNT(*) FROM deleted_exercises
`

type DeleteWorkoutsBetweenDatesParams struct {
	Email  string      `json:"email"`
	Start  pgtype.Date `json:"start"`
	Ending pgtype.Date `json:"ending"`
}

func (q *Queries) DeleteWorkoutsBetweenDates(ctx context.Context, arg DeleteWorkoutsBetweenDatesParams) (int64, error) {
	row := q.db.QueryRow(ctx, deleteWorkoutsBetweenDates, arg.Email, arg.Start, arg.Ending)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllClientsTrainingLogData = `-- name: GetAllClientsTrainingLogData :many
SELECT
	providentia.client.email,
	providentia.exercise.name,
	providentia.training_log.date_performed,
	providentia.training_log.inter_session_cntr,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.volume,
	providentia.training_log.exertion,
	providentia.training_log.total_reps
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
ORDER BY
	-- These cannot be labeled with providentia.training_log because you will
	-- get a ` + "`" + `column reference "" not found` + "`" + ` error.
	client.id DESC,
	training_log.date_performed DESC,
	training_log.id DESC
LIMIT $1
`

type GetAllClientsTrainingLogDataRow struct {
	Email            string         `json:"email"`
	Name             string         `json:"name"`
	DatePerformed    pgtype.Date    `json:"date_performed"`
	InterSessionCntr int16          `json:"inter_session_cntr"`
	Weight           types.Kilogram `json:"weight"`
	Sets             float64        `json:"sets"`
	Reps             int32          `json:"reps"`
	Effort           types.RPE      `json:"effort"`
	Volume           types.Kilogram `json:"volume"`
	Exertion         types.RPE      `json:"exertion"`
	TotalReps        float64        `json:"total_reps"`
}

func (q *Queries) GetAllClientsTrainingLogData(ctx context.Context, limit int32) ([]GetAllClientsTrainingLogDataRow, error) {
	rows, err := q.db.Query(ctx, getAllClientsTrainingLogData, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllClientsTrainingLogDataRow
	for rows.Next() {
		var i GetAllClientsTrainingLogDataRow
		if err := rows.Scan(
			&i.Email,
			&i.Name,
			&i.DatePerformed,
			&i.InterSessionCntr,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Volume,
			&i.Exertion,
			&i.TotalReps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWorkoutData = `-- name: GetAllWorkoutData :many
SELECT
	providentia.exercise.name,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.volume,
	providentia.training_log.exertion,
	providentia.training_log.total_reps,
	providentia.physics_data.time,
	providentia.physics_data.position,
	providentia.physics_data.velocity,
	providentia.physics_data.acceleration,
	providentia.physics_data.jerk,
	providentia.physics_data.force,
	providentia.physics_data.impulse,
	providentia.physics_data.work,
	providentia.physics_data.power,
	providentia.physics_data.rep_splits
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
LEFT JOIN providentia.physics_data
	ON providentia.training_log.physics_id=providentia.physics_data.id
WHERE
	providentia.client.email = $1 AND
	providentia.training_log.inter_session_cntr = $2 AND
	providentia.training_log.date_performed = $3
ORDER BY training_log.inter_workout_cntr ASC
`

type GetAllWorkoutDataParams struct {
	Email            string      `json:"email"`
	InterSessionCntr int16       `json:"inter_session_cntr"`
	DatePerformed    pgtype.Date `json:"date_performed"`
}

type GetAllWorkoutDataRow struct {
	Name         string                             `json:"name"`
	Weight       types.Kilogram                     `json:"weight"`
	Sets         float64                            `json:"sets"`
	Reps         int32                              `json:"reps"`
	Effort       types.RPE                          `json:"effort"`
	Volume       types.Kilogram                     `json:"volume"`
	Exertion     types.RPE                          `json:"exertion"`
	TotalReps    float64                            `json:"total_reps"`
	Time         [][]types.Second                   `json:"time"`
	Position     [][]types.Vec2[types.Meter]        `json:"position"`
	Velocity     [][]types.Vec2[types.MeterPerSec]  `json:"velocity"`
	Acceleration [][]types.Vec2[types.MeterPerSec2] `json:"acceleration"`
	Jerk         [][]types.Vec2[types.MeterPerSec3] `json:"jerk"`
	Force        [][]types.Vec2[types.Newton]       `json:"force"`
	Impulse      [][]types.Vec2[types.NewtonSec]    `json:"impulse"`
	Work         [][]types.Joule                    `json:"work"`
	Power        [][]types.Watt                     `json:"power"`
	RepSplits    [][]types.Split                    `json:"rep_splits"`
}

func (q *Queries) GetAllWorkoutData(ctx context.Context, arg GetAllWorkoutDataParams) ([]GetAllWorkoutDataRow, error) {
	rows, err := q.db.Query(ctx, getAllWorkoutData, arg.Email, arg.InterSessionCntr, arg.DatePerformed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllWorkoutDataRow
	for rows.Next() {
		var i GetAllWorkoutDataRow
		if err := rows.Scan(
			&i.Name,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Volume,
			&i.Exertion,
			&i.TotalReps,
			&i.Time,
			&i.Position,
			&i.Velocity,
			&i.Acceleration,
			&i.Jerk,
			&i.Force,
			&i.Impulse,
			&i.Work,
			&i.Power,
			&i.RepSplits,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWorkoutDataBetweenDates = `-- name: GetAllWorkoutDataBetweenDates :many
SELECT
	providentia.exercise.name,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort,
	providentia.training_log.volume,
	providentia.training_log.exertion,
	providentia.training_log.total_reps,
	providentia.training_log.date_performed,
	providentia.training_log.inter_session_cntr,
	providentia.physics_data.time,
	providentia.physics_data.position,
	providentia.physics_data.velocity,
	providentia.physics_data.acceleration,
	providentia.physics_data.jerk,
	providentia.physics_data.force,
	providentia.physics_data.impulse,
	providentia.physics_data.work,
	providentia.physics_data.power,
	providentia.physics_data.rep_splits
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
LEFT JOIN providentia.physics_data
	ON providentia.training_log.physics_id=providentia.physics_data.id
WHERE
	providentia.client.email = $1 AND
	providentia.training_log.date_performed BETWEEN $2::DATE AND $3::DATE
ORDER BY 
	training_log.date_performed ASC,
	training_log.inter_session_cntr ASC,
	training_log.inter_workout_cntr ASC
`

type GetAllWorkoutDataBetweenDatesParams struct {
	Email  string      `json:"email"`
	Start  pgtype.Date `json:"start"`
	Ending pgtype.Date `json:"ending"`
}

type GetAllWorkoutDataBetweenDatesRow struct {
	Name             string                             `json:"name"`
	Weight           types.Kilogram                     `json:"weight"`
	Sets             float64                            `json:"sets"`
	Reps             int32                              `json:"reps"`
	Effort           types.RPE                          `json:"effort"`
	Volume           types.Kilogram                     `json:"volume"`
	Exertion         types.RPE                          `json:"exertion"`
	TotalReps        float64                            `json:"total_reps"`
	DatePerformed    pgtype.Date                        `json:"date_performed"`
	InterSessionCntr int16                              `json:"inter_session_cntr"`
	Time             [][]types.Second                   `json:"time"`
	Position         [][]types.Vec2[types.Meter]        `json:"position"`
	Velocity         [][]types.Vec2[types.MeterPerSec]  `json:"velocity"`
	Acceleration     [][]types.Vec2[types.MeterPerSec2] `json:"acceleration"`
	Jerk             [][]types.Vec2[types.MeterPerSec3] `json:"jerk"`
	Force            [][]types.Vec2[types.Newton]       `json:"force"`
	Impulse          [][]types.Vec2[types.NewtonSec]    `json:"impulse"`
	Work             [][]types.Joule                    `json:"work"`
	Power            [][]types.Watt                     `json:"power"`
	RepSplits        [][]types.Split                    `json:"rep_splits"`
}

func (q *Queries) GetAllWorkoutDataBetweenDates(ctx context.Context, arg GetAllWorkoutDataBetweenDatesParams) ([]GetAllWorkoutDataBetweenDatesRow, error) {
	rows, err := q.db.Query(ctx, getAllWorkoutDataBetweenDates, arg.Email, arg.Start, arg.Ending)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllWorkoutDataBetweenDatesRow
	for rows.Next() {
		var i GetAllWorkoutDataBetweenDatesRow
		if err := rows.Scan(
			&i.Name,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
			&i.Volume,
			&i.Exertion,
			&i.TotalReps,
			&i.DatePerformed,
			&i.InterSessionCntr,
			&i.Time,
			&i.Position,
			&i.Velocity,
			&i.Acceleration,
			&i.Jerk,
			&i.Force,
			&i.Impulse,
			&i.Work,
			&i.Power,
			&i.RepSplits,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientTrainingLogData = `-- name: GetClientTrainingLogData :many
SELECT
	providentia.exercise.name,
	providentia.training_log.date_performed,
	providentia.training_log.inter_session_cntr,
	providentia.training_log.weight,
	providentia.training_log.sets,
	providentia.training_log.reps,
	providentia.training_log.effort
FROM providentia.training_log
JOIN providentia.exercise
	ON providentia.training_log.exercise_id=providentia.exercise.id
JOIN providentia.client
	ON providentia.training_log.client_id=providentia.client.id
WHERE providentia.client.email=$1
ORDER BY
	-- These cannot be labeled with providentia.training_log because you will
	-- get a ` + "`" + `column reference "" not found` + "`" + ` error.
	training_log.date_performed DESC, training_log.id DESC
LIMIT $2
`

type GetClientTrainingLogDataParams struct {
	Email string `json:"email"`
	Limit int32  `json:"limit"`
}

type GetClientTrainingLogDataRow struct {
	Name             string         `json:"name"`
	DatePerformed    pgtype.Date    `json:"date_performed"`
	InterSessionCntr int16          `json:"inter_session_cntr"`
	Weight           types.Kilogram `json:"weight"`
	Sets             float64        `json:"sets"`
	Reps             int32          `json:"reps"`
	Effort           types.RPE      `json:"effort"`
}

func (q *Queries) GetClientTrainingLogData(ctx context.Context, arg GetClientTrainingLogDataParams) ([]GetClientTrainingLogDataRow, error) {
	rows, err := q.db.Query(ctx, getClientTrainingLogData, arg.Email, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientTrainingLogDataRow
	for rows.Next() {
		var i GetClientTrainingLogDataRow
		if err := rows.Scan(
			&i.Name,
			&i.DatePerformed,
			&i.InterSessionCntr,
			&i.Weight,
			&i.Sets,
			&i.Reps,
			&i.Effort,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientsByEmail = `-- name: GetClientsByEmail :many
SELECT first_name, last_name, email
FROM providentia.client WHERE email = ANY($1::text[])
`

type GetClientsByEmailRow struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) GetClientsByEmail(ctx context.Context, dollar_1 []string) ([]GetClientsByEmailRow, error) {
	rows, err := q.db.Query(ctx, getClientsByEmail, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientsByEmailRow
	for rows.Next() {
		var i GetClientsByEmailRow
		if err := rows.Scan(&i.FirstName, &i.LastName, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseIDs = `-- name: GetExerciseIDs :one
SELECT
	providentia.exercise.id AS exercise_id,
	providentia.exercise_kind.id AS kind_id,
	providentia.exercise_focus.id AS focus_id
FROM providentia.exercise
JOIN providentia.exercise_kind
	ON providentia.exercise.kind_id=providentia.exercise_kind.id
JOIN providentia.exercise_focus
	ON providentia.exercise.focus_id=providentia.exercise_focus.id
WHERE name=$1
`

type GetExerciseIDsRow struct {
	ExerciseID int32 `json:"exercise_id"`
	KindID     int32 `json:"kind_id"`
	FocusID    int32 `json:"focus_id"`
}

func (q *Queries) GetExerciseIDs(ctx context.Context, name string) (GetExerciseIDsRow, error) {
	row := q.db.QueryRow(ctx, getExerciseIDs, name)
	var i GetExerciseIDsRow
	err := row.Scan(&i.ExerciseID, &i.KindID, &i.FocusID)
	return i, err
}

const getExercisesByName = `-- name: GetExercisesByName :many
SELECT name, kind_id, focus_id
FROM providentia.exercise WHERE name = ANY($1::text[])
`

type GetExercisesByNameRow struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

func (q *Queries) GetExercisesByName(ctx context.Context, dollar_1 []string) ([]GetExercisesByNameRow, error) {
	rows, err := q.db.Query(ctx, getExercisesByName, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExercisesByNameRow
	for rows.Next() {
		var i GetExercisesByNameRow
		if err := rows.Scan(&i.Name, &i.KindID, &i.FocusID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFullClientByEmail = `-- name: GetFullClientByEmail :one
SELECT id, first_name, last_name, email FROM providentia.client WHERE email = $1
`

func (q *Queries) GetFullClientByEmail(ctx context.Context, email string) (Client, error) {
	row := q.db.QueryRow(ctx, getFullClientByEmail, email)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
	)
	return i, err
}

const getFullExerciseByName = `-- name: GetFullExerciseByName :one
SELECT id, name, kind_id, focus_id FROM providentia.exercise WHERE name = $1
`

func (q *Queries) GetFullExerciseByName(ctx context.Context, name string) (Exercise, error) {
	row := q.db.QueryRow(ctx, getFullExerciseByName, name)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.KindID,
		&i.FocusID,
	)
	return i, err
}

const getNumClients = `-- name: GetNumClients :one
SELECT COUNT(*) FROM providentia.client
`

func (q *Queries) GetNumClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumClients)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumExercises = `-- name: GetNumExercises :one
SELECT COUNT(*) FROM providentia.exercise
`

func (q *Queries) GetNumExercises(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumExercises)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumWorkoutsForClient = `-- name: GetNumWorkoutsForClient :one
SELECT COUNT(*) FROM (
	SELECT date_performed, inter_session_cntr
	FROM providentia.training_log
	JOIN providentia.client
		ON providentia.training_log.client_id = providentia.client.id
	WHERE providentia.client.email = $1
	GROUP BY date_performed, inter_session_cntr
) AS result
`

func (q *Queries) GetNumWorkoutsForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getNumWorkoutsForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalNumExercisesForClient = `-- name: GetTotalNumExercisesForClient :one
SELECT COUNT(*) FROM providentia.training_log
JOIN providentia.client
	ON providentia.training_log.client_id = providentia.client.id
WHERE providentia.client.email = $1
`

func (q *Queries) GetTotalNumExercisesForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNumExercisesForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalNumPhysicsEntriesForClient = `-- name: GetTotalNumPhysicsEntriesForClient :one
SELECT COUNT(*) FROM providentia.physics_data
JOIN providentia.training_log
	ON providentia.physics_data.id = providentia.training_log.physics_id
JOIN providentia.client
	ON providentia.training_log.client_id = providentia.client.id
WHERE
	providentia.client.email = $1
`

func (q *Queries) GetTotalNumPhysicsEntriesForClient(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalNumPhysicsEntriesForClient, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateClientByEmail = `-- name: UpdateClientByEmail :exec
UPDATE providentia.client SET first_name=$1, last_name=$2
WHERE providentia.client.email=$3
`

type UpdateClientByEmailParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) UpdateClientByEmail(ctx context.Context, arg UpdateClientByEmailParams) error {
	_, err := q.db.Exec(ctx, updateClientByEmail, arg.FirstName, arg.LastName, arg.Email)
	return err
}

const updateExerciseByName = `-- name: UpdateExerciseByName :exec
UPDATE providentia.exercise SET kind_id=$2, focus_id=$3
WHERE providentia.exercise.name=$1
`

type UpdateExerciseByNameParams struct {
	Name    string              `json:"name"`
	KindID  types.ExerciseKind  `json:"kind_id"`
	FocusID types.ExerciseFocus `json:"focus_id"`
}

func (q *Queries) UpdateExerciseByName(ctx context.Context, arg UpdateExerciseByNameParams) error {
	_, err := q.db.Exec(ctx, updateExerciseByName, arg.Name, arg.KindID, arg.FocusID)
	return err
}

const updateExerciseFocusSerialCount = `-- name: UpdateExerciseFocusSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise_focus', 'id'),
	(SELECT MAX(id) FROM providentia.exercise_focus) + 1
)
`

func (q *Queries) UpdateExerciseFocusSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseFocusSerialCount)
	return err
}

const updateExerciseKindSerialCount = `-- name: UpdateExerciseKindSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise_kind', 'id'),
	(SELECT MAX(id) FROM providentia.exercise_kind) + 1
)
`

func (q *Queries) UpdateExerciseKindSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseKindSerialCount)
	return err
}

const updateExerciseSerialCount = `-- name: UpdateExerciseSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise', 'id'),
	(SELECT MAX(id) FROM providentia.exercise) + 1
)
`

func (q *Queries) UpdateExerciseSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateExerciseSerialCount)
	return err
}

const updateModelSerialCount = `-- name: UpdateModelSerialCount :exec
SELECT SETVAL(
	pg_get_serial_sequence('providentia.exercise', 'id'),
	(SELECT MAX(id) FROM providentia.exercise) + 1
)
`

func (q *Queries) UpdateModelSerialCount(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateModelSerialCount)
	return err
}
