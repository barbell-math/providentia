// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package barpathphysdata

import (
	"fmt"
	"strings"
)

const (
	// NoErr is a BarPathCalcErrCode of type NoErr.
	NoErr BarPathCalcErrCode = iota
	// TimeSeriesNotIncreasingErr is a BarPathCalcErrCode of type TimeSeriesNotIncreasingErr.
	TimeSeriesNotIncreasingErr
	// TimeSeriesNotMonotonicErr is a BarPathCalcErrCode of type TimeSeriesNotMonotonicErr.
	TimeSeriesNotMonotonicErr
	// InvalidApproximationErrErr is a BarPathCalcErrCode of type InvalidApproximationErrErr.
	InvalidApproximationErrErr
)

var ErrInvalidBarPathCalcErrCode = fmt.Errorf("not a valid BarPathCalcErrCode, try [%s]", strings.Join(_BarPathCalcErrCodeNames, ", "))

const _BarPathCalcErrCodeName = "NoErrTimeSeriesNotIncreasingErrTimeSeriesNotMonotonicErrInvalidApproximationErrErr"

var _BarPathCalcErrCodeNames = []string{
	_BarPathCalcErrCodeName[0:5],
	_BarPathCalcErrCodeName[5:31],
	_BarPathCalcErrCodeName[31:56],
	_BarPathCalcErrCodeName[56:82],
}

// BarPathCalcErrCodeNames returns a list of possible string values of BarPathCalcErrCode.
func BarPathCalcErrCodeNames() []string {
	tmp := make([]string, len(_BarPathCalcErrCodeNames))
	copy(tmp, _BarPathCalcErrCodeNames)
	return tmp
}

// BarPathCalcErrCodeValues returns a list of the values for BarPathCalcErrCode
func BarPathCalcErrCodeValues() []BarPathCalcErrCode {
	return []BarPathCalcErrCode{
		NoErr,
		TimeSeriesNotIncreasingErr,
		TimeSeriesNotMonotonicErr,
		InvalidApproximationErrErr,
	}
}

var _BarPathCalcErrCodeMap = map[BarPathCalcErrCode]string{
	NoErr:                      _BarPathCalcErrCodeName[0:5],
	TimeSeriesNotIncreasingErr: _BarPathCalcErrCodeName[5:31],
	TimeSeriesNotMonotonicErr:  _BarPathCalcErrCodeName[31:56],
	InvalidApproximationErrErr: _BarPathCalcErrCodeName[56:82],
}

// String implements the Stringer interface.
func (x BarPathCalcErrCode) String() string {
	if str, ok := _BarPathCalcErrCodeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("BarPathCalcErrCode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x BarPathCalcErrCode) IsValid() bool {
	_, ok := _BarPathCalcErrCodeMap[x]
	return ok
}

var _BarPathCalcErrCodeValue = map[string]BarPathCalcErrCode{
	_BarPathCalcErrCodeName[0:5]:                    NoErr,
	strings.ToLower(_BarPathCalcErrCodeName[0:5]):   NoErr,
	_BarPathCalcErrCodeName[5:31]:                   TimeSeriesNotIncreasingErr,
	strings.ToLower(_BarPathCalcErrCodeName[5:31]):  TimeSeriesNotIncreasingErr,
	_BarPathCalcErrCodeName[31:56]:                  TimeSeriesNotMonotonicErr,
	strings.ToLower(_BarPathCalcErrCodeName[31:56]): TimeSeriesNotMonotonicErr,
	_BarPathCalcErrCodeName[56:82]:                  InvalidApproximationErrErr,
	strings.ToLower(_BarPathCalcErrCodeName[56:82]): InvalidApproximationErrErr,
}

// ParseBarPathCalcErrCode attempts to convert a string to a BarPathCalcErrCode.
func ParseBarPathCalcErrCode(name string) (BarPathCalcErrCode, error) {
	if x, ok := _BarPathCalcErrCodeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _BarPathCalcErrCodeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return BarPathCalcErrCode(0), fmt.Errorf("%s is %w", name, ErrInvalidBarPathCalcErrCode)
}

// MarshalText implements the text marshaller method.
func (x BarPathCalcErrCode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *BarPathCalcErrCode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseBarPathCalcErrCode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *BarPathCalcErrCode) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
