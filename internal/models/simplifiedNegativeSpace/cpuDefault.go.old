//go:build !prov_gpu

package simplifiednegativespace

//go:generate go-enum --marshal --names --values --nocase

import (
	"math"
	"unsafe"

	dal "code.barbellmath.net/barbell-math/providentia/internal/db/dataAccessLayer"
	"code.barbellmath.net/barbell-math/providentia/internal/mat"
	pubenums "code.barbellmath.net/barbell-math/providentia/lib/pubEnums"
)

type (
	// ENUM(
	//	Zeta1,
	//	Eps2,
	//	Eps3,
	//	Eps6,
	//	Zeta2,
	//	Zeta3,
	//	Zeta4,
	//)
	TermIdx int

	Opts struct {
		Alpha    float64
		Beta     float64
		Gamma    float64
		MaxIters uint64
	}
)

// TODO - can these nonsense types be replaced with unsafe casts and tests/asserts
// that the underlying structs are the same??
func ModelStates(
	clientID int64,
	historicalData []dal.ClientTrainingLogDataDateRangeAscendingRow,
	needsCalc []dal.ClientTrainingLogDataDateRangeAscendingRow,
	opts Opts,
) []dal.BulkCreateModelStatesParams {
	rv := make([]dal.BulkCreateModelStatesParams, len(needsCalc))
	for i := 0; i < len(needsCalc); i++ {
		rv[i] = dal.BulkCreateModelStatesParams{
			ModelID:       int32(pubenums.ModelIDSimplifiedNegativeSpace),
			ClientID:      clientID,
			TrainingLogID: needsCalc[i].ID,
			Mse:           math.Inf(1),
			TimeFrame:     0,
			PredWeight:    0,
			V8:            max(0, opts.Alpha),
			V9:            max(0, opts.Beta),
			V10:           max(0, opts.Gamma),
		}

		iterCntr := uint64(0)
		curTerms := [7][1]float64{}
		curSmallestDelta := math.Inf(1)
		designMatrix := [7][7]float64{}

		// The -1 is important, cannot include the current data point in the
		// data set that lin reg is run on
		for j := i - 1; j >= 0 && iterCntr < opts.MaxIters; j-- {
			if needsCalc[i].ExerciseID != needsCalc[j].ExerciseID {
				continue
			}

			iterCntr++
			addDataPoint(
				&curTerms, &designMatrix, &needsCalc[i], &rv[i],
				&curSmallestDelta, &needsCalc[j], &opts,
			)
		}
		for j := len(historicalData) - 1; j >= 0 && iterCntr < opts.MaxIters; j-- {
			if needsCalc[i].ExerciseID != historicalData[j].ExerciseID {
				continue
			}

			iterCntr++
			addDataPoint(
				&curTerms, &designMatrix, &needsCalc[i], &rv[i],
				&curSmallestDelta, &historicalData[j], &opts,
			)
		}
	}

	return rv
}

func addDataPoint(
	curTerms *[7][1]float64,
	curDesignMatrix *[7][7]float64,
	curDataPoint *dal.ClientTrainingLogDataDateRangeAscendingRow,
	curModelState *dal.BulkCreateModelStatesParams,
	curSmallestDelta *float64,
	iterDataPoint *dal.ClientTrainingLogDataDateRangeAscendingRow,
	opts *Opts,
) {
	reps := float64(iterDataPoint.Reps)
	sets := float64(iterDataPoint.Sets)
	interSessionCntr := float64(iterDataPoint.InterSessionCntr)
	interWorkoutCntr := float64(iterDataPoint.InterWorkoutCntr)

	effortTerm := math.Pow(iterDataPoint.Effort, opts.Alpha)
	repsTerm := math.Pow(reps-1, opts.Beta)
	setsTerm := math.Pow(sets-1, opts.Gamma)
	repsAndEffortTerm := repsTerm * effortTerm
	setsAndEffortTerm := setsTerm * effortTerm
	setsAndRepsTerm := setsTerm * repsTerm
	setsAndRepsAndEffortTerm := effortTerm * setsAndRepsTerm

	responses := [7][1]float64{}
	additions := [7][7]float64{}
	baseTerms := [7][1]float64{
		[1]float64{1},
		[1]float64{interSessionCntr},
		[1]float64{interWorkoutCntr},
		[1]float64{effortTerm},
		[1]float64{setsAndRepsAndEffortTerm},
		[1]float64{repsAndEffortTerm},
		[1]float64{setsAndEffortTerm},
	}

	additions[0] = *(*[7]float64)(unsafe.Pointer(&baseTerms))
	// additions[0][0] = 1
	// additions[0][1] = interSessionCntr
	// additions[0][2] = interWorkoutCntr
	// additions[0][3] = effortTerm
	// additions[0][4] = setsAndRepsAndEffortTerm
	// additions[0][5] = repsAndEffortTerm
	// additions[0][6] = setsAndEffortTerm

	mat.Mul7x1ByScalar(
		baseTerms,
		interSessionCntr,
		(*[7][1]float64)(unsafe.Pointer(&additions[1])),
	)
	// additions[1][0] = interSessionCntr
	// additions[1][1] = interSessionCntr * interSessionCntr
	// additions[1][2] = interWorkoutCntr * interSessionCntr
	// additions[1][3] = effortTerm * interSessionCntr
	// additions[1][4] = setsAndRepsAndEffortTerm * interSessionCntr
	// additions[1][5] = repsAndEffortTerm * interSessionCntr
	// additions[1][6] = setsAndEffortTerm * interSessionCntr

	mat.Mul7x1ByScalar(
		baseTerms,
		interWorkoutCntr,
		(*[7][1]float64)(unsafe.Pointer(&additions[2])),
	)
	// additions[2][0] = interWorkoutCntr
	// additions[2][1] = interSessionCntr * interWorkoutCntr
	// additions[2][2] = interWorkoutCntr * interWorkoutCntr
	// additions[2][3] = effortTerm * interWorkoutCntr
	// additions[2][4] = setsAndRepsAndEffortTerm * interWorkoutCntr
	// additions[2][5] = repsAndEffortTerm * interWorkoutCntr
	// additions[2][6] = setsAndEffortTerm * interWorkoutCntr

	mat.Mul7x1ByScalar(
		baseTerms,
		effortTerm,
		(*[7][1]float64)(unsafe.Pointer(&additions[3])),
	)
	// additions[3][0] = effortTerm
	// additions[3][1] = interSessionCntr * effortTerm
	// additions[3][2] = interWorkoutCntr * effortTerm
	// additions[3][3] = effortTerm * effortTerm
	// additions[3][4] = setsAndRepsAndEffortTerm * effortTerm
	// additions[3][5] = repsAndEffortTerm * effortTerm
	// additions[3][6] = setsAndEffortTerm * effortTerm

	mat.Mul7x1ByScalar(
		baseTerms,
		setsAndRepsAndEffortTerm,
		(*[7][1]float64)(unsafe.Pointer(&additions[4])),
	)
	// additions[4][0] = setsAndRepsAndEffortTerm
	// additions[4][1] = interSessionCntr * setsAndRepsAndEffortTerm
	// additions[4][2] = interWorkoutCntr * setsAndRepsAndEffortTerm
	// additions[4][3] = effortTerm * setsAndRepsAndEffortTerm
	// additions[4][4] = setsAndRepsAndEffortTerm * setsAndRepsAndEffortTerm
	// additions[4][5] = repsAndEffortTerm * setsAndRepsAndEffortTerm
	// additions[4][6] = setsAndEffortTerm * setsAndRepsAndEffortTerm

	mat.Mul7x1ByScalar(
		baseTerms,
		repsAndEffortTerm,
		(*[7][1]float64)(unsafe.Pointer(&additions[5])),
	)
	// additions[5][0] = repsAndEffortTerm
	// additions[5][1] = interSessionCntr * repsAndEffortTerm
	// additions[5][2] = interWorkoutCntr * repsAndEffortTerm
	// additions[5][3] = effortTerm * repsAndEffortTerm
	// additions[5][4] = setsAndRepsAndEffortTerm * repsAndEffortTerm
	// additions[5][5] = repsAndEffortTerm * repsAndEffortTerm
	// additions[5][6] = setsAndEffortTerm * repsAndEffortTerm

	mat.Mul7x1ByScalar(
		baseTerms,
		setsAndEffortTerm,
		(*[7][1]float64)(unsafe.Pointer(&additions[6])),
	)
	// additions[6][0] = setsAndEffortTerm
	// additions[6][1] = interSessionCntr * setsAndEffortTerm
	// additions[6][2] = interWorkoutCntr * setsAndEffortTerm
	// additions[6][3] = effortTerm * setsAndEffortTerm
	// additions[6][4] = setsAndRepsAndEffortTerm * setsAndEffortTerm
	// additions[6][5] = repsAndEffortTerm * setsAndEffortTerm
	// additions[6][6] = setsAndEffortTerm * setsAndEffortTerm

	mat.Add7x7By7x7(*curDesignMatrix, additions, curDesignMatrix)
	mat.Mul7x1ByScalar(baseTerms, iterDataPoint.Weight, &responses)
	// responses[0][0] = iterDataPoint.Weight
	// responses[1][0] = iterDataPoint.Weight * interSessionCntr
	// responses[2][0] = iterDataPoint.Weight * interWorkoutCntr
	// responses[3][0] = iterDataPoint.Weight * effortTerm
	// responses[4][0] = iterDataPoint.Weight * setsAndRepsAndEffortTerm
	// responses[5][0] = iterDataPoint.Weight * repsAndEffortTerm
	// responses[6][0] = iterDataPoint.Weight * setsAndEffortTerm

	// TODO - this is where things go wrong - need to compute inverse of design
	// A=M1*M2
	// M1*y=b - solve for y using back subsitution
	// M2*x=y - solve for x using back subsitution

	// mat.Mul7x7By7x1(*curDesignMatrix, responses, curTerms)

	// Constrain terms to the valid range for each constant
	// TODO - how to replace with mat funcs?
	for i := 0; i < 7; i++ {
		curTerms[i][0] = max(0, curTerms[i][0])
	}

	// TODO - replace with curTerms*base vector followed by reduction somehow
	// Mul1x7By7x1 ??
	pred := curTerms[TermIdxZeta1][0]
	pred += curTerms[TermIdxEps2][0] * interSessionCntr
	pred += curTerms[TermIdxEps3][0] * interWorkoutCntr
	pred += curTerms[TermIdxEps6][0] * effortTerm
	pred += curTerms[TermIdxZeta2][0] * setsAndRepsAndEffortTerm
	pred += curTerms[TermIdxZeta3][0] * repsAndEffortTerm
	pred += curTerms[TermIdxZeta4][0] * setsAndEffortTerm

	delta := pred - curDataPoint.Weight
	if delta < *curSmallestDelta {
		*curSmallestDelta = delta
		curModelState.Mse = delta * delta
		curModelState.TimeFrame = int32(
			curDataPoint.DatePerformed.Time.Sub(
				iterDataPoint.DatePerformed.Time,
			).Hours() / 24,
		)
		curModelState.PredWeight = pred

		curModelState.V1 = curTerms[TermIdxZeta1][0]
		curModelState.V2 = curTerms[TermIdxEps2][0]
		curModelState.V3 = curTerms[TermIdxEps3][0]
		curModelState.V4 = curTerms[TermIdxEps6][0]
		curModelState.V5 = curTerms[TermIdxZeta2][0]
		curModelState.V6 = curTerms[TermIdxZeta3][0]
		curModelState.V7 = curTerms[TermIdxZeta4][0]
	}
}
